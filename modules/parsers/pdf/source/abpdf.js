// Generated by CommonJS Everywhere 0.9.7
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v0.12.6',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setABTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/abpdfparser.js', function (module, exports, __dirname, __filename) {
    var PDFParser = require('/pdfparser.js', module), PDFCanvas = require('/lib/pdfcanvas.js', module), Buffer = require('buffer', module).Buffer;

    var globalScope = Function('return this')();
    globalScope.PDFCanvas = PDFCanvas;

    var ABPDFParser = function () {
        return {
          parseTextFromBase64: function (pdfContent) {
            var pdfParser = new PDFParser(null, true);
            function dataReady(pdfjs) {
              AnyBalance.trace('ready: ' + pdfjs);
            }
            function dataError(pdfjs) {
              AnyBalance.trace('error: ' + pdfjs);
            }
            pdfParser.on('pdfParser_dataReady', dataReady);
            pdfParser.on('pdfParser_dataError', dataError);
            var pdfBuffer = new Buffer(pdfContent, 'base64');
            pdfParser.parseBuffer(pdfBuffer);
            if (typeof processABTimeouts == 'function')
              processABTimeouts();
            AnyBalance.trace('parsing finished');
            return pdfParser.getRawTextContent();
          }
        };
      }();
    module.exports = ABPDFParser;
  });
  require.define('buffer', function (module, exports, __dirname, __filename) {
    var assert;
    exports.Buffer = Buffer;
    exports.SlowBuffer = Buffer;
    Buffer.poolSize = 8192;
    exports.INSPECT_MAX_BYTES = 50;
    function stringtrim(str) {
      if (str.trim)
        return str.trim();
      return str.replace(/^\s+|\s+$/g, '');
    }
    function Buffer(subject, encoding, offset) {
      if (!assert)
        assert = require('assert', module);
      if (!(this instanceof Buffer)) {
        return new Buffer(subject, encoding, offset);
      }
      this.parent = this;
      this.offset = 0;
      if (encoding == 'base64' && typeof subject == 'string') {
        subject = stringtrim(subject);
        while (subject.length % 4 != 0) {
          subject = subject + '=';
        }
      }
      var type;
      if (typeof offset === 'number') {
        this.length = coerce(encoding);
        for (var i = 0; i < this.length; i++) {
          this[i] = subject.get(i + offset);
        }
      } else {
        switch (type = typeof subject) {
        case 'number':
          this.length = coerce(subject);
          break;
        case 'string':
          this.length = Buffer.byteLength(subject, encoding);
          break;
        case 'object':
          this.length = coerce(subject.length);
          break;
        default:
          throw new TypeError('First argument needs to be a number, ' + 'array or string.');
        }
        if (isArrayIsh(subject)) {
          for (var i = 0; i < this.length; i++) {
            if (subject instanceof Buffer) {
              this[i] = subject.readUInt8(i);
            } else {
              this[i] = (subject[i] % 256 + 256) % 256;
            }
          }
        } else if (type == 'string') {
          this.length = this.write(subject, 0, encoding);
        } else if (type === 'number') {
          for (var i = 0; i < this.length; i++) {
            this[i] = 0;
          }
        }
      }
    }
    Buffer.prototype.get = function get(i) {
      if (i < 0 || i >= this.length)
        throw new Error('oob');
      return this[i];
    };
    Buffer.prototype.set = function set(i, v) {
      if (i < 0 || i >= this.length)
        throw new Error('oob');
      return this[i] = v;
    };
    Buffer.byteLength = function (str, encoding) {
      switch (encoding || 'utf8') {
      case 'hex':
        return str.length / 2;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(str).length;
      case 'ascii':
      case 'binary':
        return str.length;
      case 'base64':
        return base64ToBytes(str).length;
      default:
        throw new Error('Unknown encoding');
      }
    };
    Buffer.prototype.utf8Write = function (string, offset, length) {
      var bytes, pos;
      return Buffer._charsWritten = blitBuffer(utf8ToBytes(string), this, offset, length);
    };
    Buffer.prototype.asciiWrite = function (string, offset, length) {
      var bytes, pos;
      return Buffer._charsWritten = blitBuffer(asciiToBytes(string), this, offset, length);
    };
    Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;
    Buffer.prototype.base64Write = function (string, offset, length) {
      var bytes, pos;
      return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
    };
    Buffer.prototype.base64Slice = function (start, end) {
      var bytes = Array.prototype.slice.apply(this, arguments);
      return require('/../commonjs-everywhere/node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js', module).fromByteArray(bytes);
    };
    Buffer.prototype.utf8Slice = function () {
      var bytes = Array.prototype.slice.apply(this, arguments);
      var res = '';
      var tmp = '';
      var i = 0;
      while (i < bytes.length) {
        if (bytes[i] <= 127) {
          res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
          tmp = '';
        } else
          tmp += '%' + bytes[i].toString(16);
        i++;
      }
      return res + decodeUtf8Char(tmp);
    };
    Buffer.prototype.asciiSlice = function () {
      var bytes = Array.prototype.slice.apply(this, arguments);
      var ret = '';
      for (var i = 0; i < bytes.length; i++)
        ret += String.fromCharCode(bytes[i]);
      return ret;
    };
    Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;
    Buffer.prototype.inspect = function () {
      var out = [], len = this.length;
      for (var i = 0; i < len; i++) {
        out[i] = toHex(this[i]);
        if (i == exports.INSPECT_MAX_BYTES) {
          out[i + 1] = '...';
          break;
        }
      }
      return '<Buffer ' + out.join(' ') + '>';
    };
    Buffer.prototype.hexSlice = function (start, end) {
      var len = this.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = '';
      for (var i = start; i < end; i++) {
        out += toHex(this[i]);
      }
      return out;
    };
    Buffer.prototype.toString = function (encoding, start, end) {
      encoding = String(encoding || 'utf8').toLowerCase();
      start = +start || 0;
      if (typeof end == 'undefined')
        end = this.length;
      if (+end == start) {
        return '';
      }
      switch (encoding) {
      case 'hex':
        return this.hexSlice(start, end);
      case 'utf8':
      case 'utf-8':
        return this.utf8Slice(start, end);
      case 'ascii':
        return this.asciiSlice(start, end);
      case 'binary':
        return this.binarySlice(start, end);
      case 'base64':
        return this.base64Slice(start, end);
      case 'ucs2':
      case 'ucs-2':
        return this.ucs2Slice(start, end);
      default:
        throw new Error('Unknown encoding');
      }
    };
    Buffer.prototype.hexWrite = function (string, offset, length) {
      offset = +offset || 0;
      var remaining = this.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = +length;
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (strLen % 2) {
        throw new Error('Invalid hex string');
      }
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; i++) {
        var b = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(b))
          throw new Error('Invalid hex string');
        this[offset + i] = b;
      }
      Buffer._charsWritten = i * 2;
      return i;
    };
    Buffer.prototype.write = function (string, offset, length, encoding) {
      if (isFinite(offset)) {
        if (!isFinite(length)) {
          encoding = length;
          length = undefined;
        }
      } else {
        var swap = encoding;
        encoding = offset;
        offset = length;
        length = swap;
      }
      offset = +offset || 0;
      var remaining = this.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = +length;
        if (length > remaining) {
          length = remaining;
        }
      }
      encoding = String(encoding || 'utf8').toLowerCase();
      switch (encoding) {
      case 'hex':
        return this.hexWrite(string, offset, length);
      case 'utf8':
      case 'utf-8':
        return this.utf8Write(string, offset, length);
      case 'ascii':
        return this.asciiWrite(string, offset, length);
      case 'binary':
        return this.binaryWrite(string, offset, length);
      case 'base64':
        return this.base64Write(string, offset, length);
      case 'ucs2':
      case 'ucs-2':
        return this.ucs2Write(string, offset, length);
      default:
        throw new Error('Unknown encoding');
      }
    };
    function clamp(index, len, defaultValue) {
      if (typeof index !== 'number')
        return defaultValue;
      index = ~~index;
      if (index >= len)
        return len;
      if (index >= 0)
        return index;
      index += len;
      if (index >= 0)
        return index;
      return 0;
    }
    Buffer.prototype.slice = function (start, end) {
      var len = this.length;
      start = clamp(start, len, 0);
      end = clamp(end, len, len);
      return new Buffer(this, end - start, +start);
    };
    Buffer.prototype.copy = function (target, target_start, start, end) {
      var source = this;
      start || (start = 0);
      if (end === undefined || isNaN(end)) {
        end = this.length;
      }
      target_start || (target_start = 0);
      if (end < start)
        throw new Error('sourceEnd < sourceStart');
      if (end === start)
        return 0;
      if (target.length == 0 || source.length == 0)
        return 0;
      if (target_start < 0 || target_start >= target.length) {
        throw new Error('targetStart out of bounds');
      }
      if (start < 0 || start >= source.length) {
        throw new Error('sourceStart out of bounds');
      }
      if (end < 0 || end > source.length) {
        throw new Error('sourceEnd out of bounds');
      }
      if (end > this.length) {
        end = this.length;
      }
      if (target.length - target_start < end - start) {
        end = target.length - target_start + start;
      }
      var temp = [];
      for (var i = start; i < end; i++) {
        assert.ok(typeof this[i] !== 'undefined', 'copying undefined buffer bytes!');
        temp.push(this[i]);
      }
      for (var i = target_start; i < target_start + temp.length; i++) {
        target[i] = temp[i - target_start];
      }
    };
    Buffer.prototype.fill = function fill(value, start, end) {
      value || (value = 0);
      start || (start = 0);
      end || (end = this.length);
      if (typeof value === 'string') {
        value = value.charCodeAt(0);
      }
      if (!(typeof value === 'number') || isNaN(value)) {
        throw new Error('value is not a number');
      }
      if (end < start)
        throw new Error('end < start');
      if (end === start)
        return 0;
      if (this.length == 0)
        return 0;
      if (start < 0 || start >= this.length) {
        throw new Error('start out of bounds');
      }
      if (end < 0 || end > this.length) {
        throw new Error('end out of bounds');
      }
      for (var i = start; i < end; i++) {
        this[i] = value;
      }
    };
    Buffer.isBuffer = function isBuffer(b) {
      return b instanceof Buffer;
    };
    Buffer.concat = function (list, totalLength) {
      if (!isArray(list)) {
        throw new Error('Usage: Buffer.concat(list, [totalLength])\n       list should be an Array.');
      }
      if (list.length === 0) {
        return new Buffer(0);
      } else if (list.length === 1) {
        return list[0];
      }
      if (typeof totalLength !== 'number') {
        totalLength = 0;
        for (var i = 0; i < list.length; i++) {
          var buf = list[i];
          totalLength += buf.length;
        }
      }
      var buffer = new Buffer(totalLength);
      var pos = 0;
      for (var i = 0; i < list.length; i++) {
        var buf = list[i];
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer.isEncoding = function (encoding) {
      switch ((encoding + '').toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
      case 'raw':
        return true;
      default:
        return false;
      }
    };
    function coerce(length) {
      length = ~~Math.ceil(+length);
      return length < 0 ? 0 : length;
    }
    function isArray(subject) {
      return (Array.isArray || function (subject) {
        return {}.toString.apply(subject) == '[object Array]';
      })(subject);
    }
    function isArrayIsh(subject) {
      return isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === 'object' && typeof subject.length === 'number';
    }
    function toHex(n) {
      if (n < 16)
        return '0' + n.toString(16);
      return n.toString(16);
    }
    function utf8ToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; i++)
        if (str.charCodeAt(i) <= 127)
          byteArray.push(str.charCodeAt(i));
        else {
          var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
          for (var j = 0; j < h.length; j++)
            byteArray.push(parseInt(h[j], 16));
        }
      return byteArray;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; i++)
        byteArray.push(str.charCodeAt(i) & 255);
      return byteArray;
    }
    function base64ToBytes(str) {
      return require('/../commonjs-everywhere/node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js', module).toByteArray(str);
    }
    function blitBuffer(src, dst, offset, length) {
      dst.uint8array = src;
      var pos, i = 0;
      while (i < length) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
        i++;
      }
      return i;
    }
    function decodeUtf8Char(str) {
      try {
        return decodeURIComponent(str);
      } catch (err) {
        return String.fromCharCode(65533);
      }
    }
    Buffer.prototype.readUInt8 = function (offset, noAssert) {
      var buffer = this;
      if (!noAssert) {
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset < buffer.length, 'Trying to read beyond buffer length');
      }
      if (offset >= buffer.length)
        return;
      return buffer[offset];
    };
    function readUInt16(buffer, offset, isBigEndian, noAssert) {
      var val = 0;
      if (!noAssert) {
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 1 < buffer.length, 'Trying to read beyond buffer length');
      }
      if (offset >= buffer.length)
        return 0;
      if (isBigEndian) {
        val = buffer[offset] << 8;
        if (offset + 1 < buffer.length) {
          val |= buffer[offset + 1];
        }
      } else {
        val = buffer[offset];
        if (offset + 1 < buffer.length) {
          val |= buffer[offset + 1] << 8;
        }
      }
      return val;
    }
    Buffer.prototype.readUInt16LE = function (offset, noAssert) {
      return readUInt16(this, offset, false, noAssert);
    };
    Buffer.prototype.readUInt16BE = function (offset, noAssert) {
      return readUInt16(this, offset, true, noAssert);
    };
    function readUInt32(buffer, offset, isBigEndian, noAssert) {
      var val = 0;
      if (!noAssert) {
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 3 < buffer.length, 'Trying to read beyond buffer length');
      }
      if (offset >= buffer.length)
        return 0;
      if (isBigEndian) {
        if (offset + 1 < buffer.length)
          val = buffer[offset + 1] << 16;
        if (offset + 2 < buffer.length)
          val |= buffer[offset + 2] << 8;
        if (offset + 3 < buffer.length)
          val |= buffer[offset + 3];
        val = val + (buffer[offset] << 24 >>> 0);
      } else {
        if (offset + 2 < buffer.length)
          val = buffer[offset + 2] << 16;
        if (offset + 1 < buffer.length)
          val |= buffer[offset + 1] << 8;
        val |= buffer[offset];
        if (offset + 3 < buffer.length)
          val = val + (buffer[offset + 3] << 24 >>> 0);
      }
      return val;
    }
    Buffer.prototype.readUInt32LE = function (offset, noAssert) {
      return readUInt32(this, offset, false, noAssert);
    };
    Buffer.prototype.readUInt32BE = function (offset, noAssert) {
      return readUInt32(this, offset, true, noAssert);
    };
    Buffer.prototype.readInt8 = function (offset, noAssert) {
      var buffer = this;
      var neg;
      if (!noAssert) {
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset < buffer.length, 'Trying to read beyond buffer length');
      }
      if (offset >= buffer.length)
        return;
      neg = buffer[offset] & 128;
      if (!neg) {
        return buffer[offset];
      }
      return (255 - buffer[offset] + 1) * -1;
    };
    function readInt16(buffer, offset, isBigEndian, noAssert) {
      var neg, val;
      if (!noAssert) {
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 1 < buffer.length, 'Trying to read beyond buffer length');
      }
      val = readUInt16(buffer, offset, isBigEndian, noAssert);
      neg = val & 32768;
      if (!neg) {
        return val;
      }
      return (65535 - val + 1) * -1;
    }
    Buffer.prototype.readInt16LE = function (offset, noAssert) {
      return readInt16(this, offset, false, noAssert);
    };
    Buffer.prototype.readInt16BE = function (offset, noAssert) {
      return readInt16(this, offset, true, noAssert);
    };
    function readInt32(buffer, offset, isBigEndian, noAssert) {
      var neg, val;
      if (!noAssert) {
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 3 < buffer.length, 'Trying to read beyond buffer length');
      }
      val = readUInt32(buffer, offset, isBigEndian, noAssert);
      neg = val & 2147483648;
      if (!neg) {
        return val;
      }
      return (4294967295 - val + 1) * -1;
    }
    Buffer.prototype.readInt32LE = function (offset, noAssert) {
      return readInt32(this, offset, false, noAssert);
    };
    Buffer.prototype.readInt32BE = function (offset, noAssert) {
      return readInt32(this, offset, true, noAssert);
    };
    function readFloat(buffer, offset, isBigEndian, noAssert) {
      if (!noAssert) {
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset + 3 < buffer.length, 'Trying to read beyond buffer length');
      }
      return require('/../commonjs-everywhere/node_modules/buffer-browserify/buffer_ieee754.js', module).readIEEE754(buffer, offset, isBigEndian, 23, 4);
    }
    Buffer.prototype.readFloatLE = function (offset, noAssert) {
      return readFloat(this, offset, false, noAssert);
    };
    Buffer.prototype.readFloatBE = function (offset, noAssert) {
      return readFloat(this, offset, true, noAssert);
    };
    function readDouble(buffer, offset, isBigEndian, noAssert) {
      if (!noAssert) {
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset + 7 < buffer.length, 'Trying to read beyond buffer length');
      }
      return require('/../commonjs-everywhere/node_modules/buffer-browserify/buffer_ieee754.js', module).readIEEE754(buffer, offset, isBigEndian, 52, 8);
    }
    Buffer.prototype.readDoubleLE = function (offset, noAssert) {
      return readDouble(this, offset, false, noAssert);
    };
    Buffer.prototype.readDoubleBE = function (offset, noAssert) {
      return readDouble(this, offset, true, noAssert);
    };
    function verifuint(value, max) {
      assert.ok(typeof value == 'number', 'cannot write a non-number as a number');
      assert.ok(value >= 0, 'specified a negative value for writing an unsigned value');
      assert.ok(value <= max, 'value is larger than maximum value for type');
      assert.ok(Math.floor(value) === value, 'value has a fractional component');
    }
    Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
      var buffer = this;
      if (!noAssert) {
        assert.ok(value !== undefined && value !== null, 'missing value');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset < buffer.length, 'trying to write beyond buffer length');
        verifuint(value, 255);
      }
      if (offset < buffer.length) {
        buffer[offset] = value;
      }
    };
    function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
      if (!noAssert) {
        assert.ok(value !== undefined && value !== null, 'missing value');
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 1 < buffer.length, 'trying to write beyond buffer length');
        verifuint(value, 65535);
      }
      for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
        buffer[offset + i] = (value & 255 << 8 * (isBigEndian ? 1 - i : i)) >>> (isBigEndian ? 1 - i : i) * 8;
      }
    }
    Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
      writeUInt16(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
      writeUInt16(this, value, offset, true, noAssert);
    };
    function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
      if (!noAssert) {
        assert.ok(value !== undefined && value !== null, 'missing value');
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 3 < buffer.length, 'trying to write beyond buffer length');
        verifuint(value, 4294967295);
      }
      for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
        buffer[offset + i] = value >>> (isBigEndian ? 3 - i : i) * 8 & 255;
      }
    }
    Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
      writeUInt32(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
      writeUInt32(this, value, offset, true, noAssert);
    };
    function verifsint(value, max, min) {
      assert.ok(typeof value == 'number', 'cannot write a non-number as a number');
      assert.ok(value <= max, 'value larger than maximum allowed value');
      assert.ok(value >= min, 'value smaller than minimum allowed value');
      assert.ok(Math.floor(value) === value, 'value has a fractional component');
    }
    function verifIEEE754(value, max, min) {
      assert.ok(typeof value == 'number', 'cannot write a non-number as a number');
      assert.ok(value <= max, 'value larger than maximum allowed value');
      assert.ok(value >= min, 'value smaller than minimum allowed value');
    }
    Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
      var buffer = this;
      if (!noAssert) {
        assert.ok(value !== undefined && value !== null, 'missing value');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset < buffer.length, 'Trying to write beyond buffer length');
        verifsint(value, 127, -128);
      }
      if (value >= 0) {
        buffer.writeUInt8(value, offset, noAssert);
      } else {
        buffer.writeUInt8(255 + value + 1, offset, noAssert);
      }
    };
    function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
      if (!noAssert) {
        assert.ok(value !== undefined && value !== null, 'missing value');
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 1 < buffer.length, 'Trying to write beyond buffer length');
        verifsint(value, 32767, -32768);
      }
      if (value >= 0) {
        writeUInt16(buffer, value, offset, isBigEndian, noAssert);
      } else {
        writeUInt16(buffer, 65535 + value + 1, offset, isBigEndian, noAssert);
      }
    }
    Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
      writeInt16(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
      writeInt16(this, value, offset, true, noAssert);
    };
    function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
      if (!noAssert) {
        assert.ok(value !== undefined && value !== null, 'missing value');
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 3 < buffer.length, 'Trying to write beyond buffer length');
        verifsint(value, 2147483647, -2147483648);
      }
      if (value >= 0) {
        writeUInt32(buffer, value, offset, isBigEndian, noAssert);
      } else {
        writeUInt32(buffer, 4294967295 + value + 1, offset, isBigEndian, noAssert);
      }
    }
    Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
      writeInt32(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
      writeInt32(this, value, offset, true, noAssert);
    };
    function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
      if (!noAssert) {
        assert.ok(value !== undefined && value !== null, 'missing value');
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 3 < buffer.length, 'Trying to write beyond buffer length');
        verifIEEE754(value, 3.4028234663852886e38, -3.4028234663852886e38);
      }
      require('/../commonjs-everywhere/node_modules/buffer-browserify/buffer_ieee754.js', module).writeIEEE754(buffer, value, offset, isBigEndian, 23, 4);
    }
    Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
      writeFloat(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
      writeFloat(this, value, offset, true, noAssert);
    };
    function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
      if (!noAssert) {
        assert.ok(value !== undefined && value !== null, 'missing value');
        assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
        assert.ok(offset !== undefined && offset !== null, 'missing offset');
        assert.ok(offset + 7 < buffer.length, 'Trying to write beyond buffer length');
        verifIEEE754(value, 1.7976931348623157e308, -1.7976931348623157e308);
      }
      require('/../commonjs-everywhere/node_modules/buffer-browserify/buffer_ieee754.js', module).writeIEEE754(buffer, value, offset, isBigEndian, 52, 8);
    }
    Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
      writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
      writeDouble(this, value, offset, true, noAssert);
    };
  });
  require.define('/../commonjs-everywhere/node_modules/buffer-browserify/buffer_ieee754.js', function (module, exports, __dirname, __filename) {
    exports.readIEEE754 = function (buffer, offset, isBE, mLen, nBytes) {
      var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isBE ? 0 : nBytes - 1, d = isBE ? 1 : -1, s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.writeIEEE754 = function (buffer, value, offset, isBE, mLen, nBytes) {
      var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isBE ? nBytes - 1 : 0, d = isBE ? -1 : 1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
      buffer[offset + i - d] |= s * 128;
    };
  });
  require.define('/../commonjs-everywhere/node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js', function (module, exports, __dirname, __filename) {
    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    ;
    (function (exports) {
      'use strict';
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
      var PLUS = '+'.charCodeAt(0);
      var SLASH = '/'.charCodeAt(0);
      var NUMBER = '0'.charCodeAt(0);
      var LOWER = 'a'.charCodeAt(0);
      var UPPER = 'A'.charCodeAt(0);
      var PLUS_URL_SAFE = '-'.charCodeAt(0);
      var SLASH_URL_SAFE = '_'.charCodeAt(0);
      function decode(elt) {
        var code = elt.charCodeAt(0);
        if (code === PLUS || code === PLUS_URL_SAFE)
          return 62;
        if (code === SLASH || code === SLASH_URL_SAFE)
          return 63;
        if (code < NUMBER)
          return -1;
        if (code < NUMBER + 10)
          return code - NUMBER + 26 + 26;
        if (code < UPPER + 26)
          return code - UPPER;
        if (code < LOWER + 26)
          return code - LOWER + 26;
      }
      function b64ToByteArray(b64) {
        var i, j, l, tmp, placeHolders, arr;
        if (b64.length % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        }
        var len = b64.length;
        placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
        arr = new Arr(b64.length * 3 / 4 - placeHolders);
        l = placeHolders > 0 ? b64.length - 4 : b64.length;
        var L = 0;
        function push(v) {
          arr[L++] = v;
        }
        for (i = 0, j = 0; i < l; i += 4, j += 3) {
          tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
          push((tmp & 16711680) >> 16);
          push((tmp & 65280) >> 8);
          push(tmp & 255);
        }
        if (placeHolders === 2) {
          tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
          push(tmp & 255);
        } else if (placeHolders === 1) {
          tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
          push(tmp >> 8 & 255);
          push(tmp & 255);
        }
        return arr;
      }
      function uint8ToBase64(uint8) {
        var i, extraBytes = uint8.length % 3, output = '', temp, length;
        function encode(num) {
          return lookup.charAt(num);
        }
        function tripletToBase64(num) {
          return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
        }
        for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
          temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
          output += tripletToBase64(temp);
        }
        switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode(temp << 4 & 63);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
          output += encode(temp >> 10);
          output += encode(temp >> 4 & 63);
          output += encode(temp << 2 & 63);
          output += '=';
          break;
        }
        return output;
      }
      exports.toByteArray = b64ToByteArray;
      exports.fromByteArray = uint8ToBase64;
    }(typeof exports === 'undefined' ? this.base64js = {} : exports));
  });
  require.define('assert', function (module, exports, __dirname, __filename) {
    var util = require('util', module);
    var pSlice = Array.prototype.slice;
    var assert = module.exports = ok;
    assert.AssertionError = function AssertionError(options) {
      this.name = 'AssertionError';
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;
      this.message = options.message || getMessage(this);
      var stackStartFunction = options.stackStartFunction || fail;
      Error.captureStackTrace(this, stackStartFunction);
    };
    util.inherits(assert.AssertionError, Error);
    function replacer(key, value) {
      if (value === undefined) {
        return '' + value;
      }
      if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
        return value.toString();
      }
      if (typeof value === 'function' || value instanceof RegExp) {
        return value.toString();
      }
      return value;
    }
    function truncate(s, n) {
      if (typeof s == 'string') {
        return s.length < n ? s : s.slice(0, n);
      } else {
        return s;
      }
    }
    function getMessage(self) {
      return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' + self.operator + ' ' + truncate(JSON.stringify(self.expected, replacer), 128);
    }
    function fail(actual, expected, message, operator, stackStartFunction) {
      throw new assert.AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFunction: stackStartFunction
      });
    }
    assert.fail = fail;
    function ok(value, message) {
      if (!!!value)
        fail(value, true, message, '==', assert.ok);
    }
    assert.ok = ok;
    assert.equal = function equal(actual, expected, message) {
      if (actual != expected)
        fail(actual, expected, message, '==', assert.equal);
    };
    assert.notEqual = function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, '!=', assert.notEqual);
      }
    };
    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected)) {
        fail(actual, expected, message, 'deepEqual', assert.deepEqual);
      }
    };
    function _deepEqual(actual, expected) {
      if (actual === expected) {
        return true;
      } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
        if (actual.length != expected.length)
          return false;
        for (var i = 0; i < actual.length; i++) {
          if (actual[i] !== expected[i])
            return false;
        }
        return true;
      } else if (actual instanceof Date && expected instanceof Date) {
        return actual.getTime() === expected.getTime();
      } else if (actual instanceof RegExp && expected instanceof RegExp) {
        return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
      } else if (typeof actual != 'object' && typeof expected != 'object') {
        return actual == expected;
      } else {
        return objEquiv(actual, expected);
      }
    }
    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }
    function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    function objEquiv(a, b) {
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
        return false;
      if (a.prototype !== b.prototype)
        return false;
      if (isArguments(a)) {
        if (!isArguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b);
      }
      try {
        var ka = Object.keys(a), kb = Object.keys(b), key, i;
      } catch (e) {
        return false;
      }
      if (ka.length != kb.length)
        return false;
      ka.sort();
      kb.sort();
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key]))
          return false;
      }
      return true;
    }
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (_deepEqual(actual, expected)) {
        fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
      }
    };
    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, '===', assert.strictEqual);
      }
    };
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, '!==', assert.notStrictEqual);
      }
    };
    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }
      if (Object.prototype.toString.call(expected) == '[object RegExp]') {
        return expected.test(actual);
      } else if (actual instanceof expected) {
        return true;
      } else if (expected.call({}, actual) === true) {
        return true;
      }
      return false;
    }
    function _throws(shouldThrow, block, expected, message) {
      var actual;
      if (typeof expected === 'string') {
        message = expected;
        expected = null;
      }
      try {
        block();
      } catch (e) {
        actual = e;
      }
      message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
      if (shouldThrow && !actual) {
        fail(actual, expected, 'Missing expected exception' + message);
      }
      if (!shouldThrow && expectedException(actual, expected)) {
        fail(actual, expected, 'Got unwanted exception' + message);
      }
      if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
        throw actual;
      }
    }
    assert.throws = function (block, error, message) {
      _throws.apply(this, [true].concat(pSlice.call(arguments)));
    };
    assert.doesNotThrow = function (block, message) {
      _throws.apply(this, [false].concat(pSlice.call(arguments)));
    };
    assert.ifError = function (err) {
      if (err) {
        throw err;
      }
    };
  });
  require.define('util', function (module, exports, __dirname, __filename) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function (f) {
      if (typeof f !== 'string') {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
          if (x === '%%')
            return '%';
          if (i >= len)
            return x;
          switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            return JSON.stringify(args[i++]);
          default:
            return x;
          }
        });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (x === null || typeof x !== 'object') {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function (fn, msg) {
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    exports.print = function () {
      for (var i = 0, len = arguments.length; i < len; ++i) {
        process.stdout.write(String(arguments[i]));
      }
    };
    exports.puts = function () {
      for (var i = 0, len = arguments.length; i < len; ++i) {
        process.stdout.write(arguments[i] + '\n');
      }
    };
    exports.debug = function (x) {
      process.stderr.write('DEBUG: ' + x + '\n');
    };
    var error = exports.error = function (x) {
        for (var i = 0, len = arguments.length; i < len; ++i) {
          process.stderr.write(arguments[i] + '\n');
        }
      };
    function inspect(obj, opts) {
      var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (typeof opts === 'boolean') {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (typeof ctx.showHidden === 'undefined')
        ctx.showHidden = false;
      if (typeof ctx.depth === 'undefined')
        ctx.depth = 2;
      if (typeof ctx.colors === 'undefined')
        ctx.colors = false;
      if (typeof ctx.customInspect === 'undefined')
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [
        1,
        22
      ],
      'italic': [
        3,
        23
      ],
      'underline': [
        4,
        24
      ],
      'inverse': [
        7,
        27
      ],
      'white': [
        37,
        39
      ],
      'grey': [
        90,
        39
      ],
      'black': [
        30,
        39
      ],
      'blue': [
        34,
        39
      ],
      'cyan': [
        36,
        39
      ],
      'green': [
        32,
        39
      ],
      'magenta': [
        35,
        39
      ],
      'red': [
        31,
        39
      ],
      'yellow': [
        33,
        39
      ]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && typeof value.inspect === 'function' && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        return String(value.inspect(recurseTimes));
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (keys.length === 0) {
        if (typeof value === 'function') {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '', array = false, braces = [
          '{',
          '}'
        ];
      if (isArray(value)) {
        array = true;
        braces = [
          '[',
          ']'
        ];
      }
      if (typeof value === 'function') {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      switch (typeof value) {
      case 'undefined':
        return ctx.stylize('undefined', 'undefined');
      case 'string':
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      case 'number':
        return ctx.stylize('' + value, 'number');
      case 'boolean':
        return ctx.stylize('' + value, 'boolean');
      }
      if (value === null) {
        return ctx.stylize('null', 'null');
      }
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (recurseTimes === null) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
          numLinesEst++;
          if (cur.indexOf('\n') >= 0)
            numLinesEst++;
          return prev + cur.length + 1;
        }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
    }
    exports.isArray = isArray;
    function isRegExp(re) {
      return typeof re === 'object' && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isDate(d) {
      return typeof d === 'object' && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return typeof e === 'object' && objectToString(e) === '[object Error]';
    }
    exports.isError = isError;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    exports.p = exports.deprecate(function () {
      for (var i = 0, len = arguments.length; i < len; ++i) {
        error(exports.inspect(arguments[i]));
      }
    }, 'util.p: Use console.error() instead.');
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ];
    function timestamp() {
      var d = new Date;
      var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(':');
      return [
        d.getDate(),
        months[d.getMonth()],
        time
      ].join(' ');
    }
    exports.log = function (msg) {
      exports.puts(timestamp() + ' - ' + msg.toString());
    };
    exports.exec = exports.deprecate(function () {
      return null.exec.apply(this, arguments);
    }, 'util.exec is now called `child_process.exec`.');
    function pump(readStream, writeStream, callback) {
      var callbackCalled = false;
      function call(a, b, c) {
        if (callback && !callbackCalled) {
          callback(a, b, c);
          callbackCalled = true;
        }
      }
      readStream.addListener('data', function (chunk) {
        if (writeStream.write(chunk) === false)
          readStream.pause();
      });
      writeStream.addListener('drain', function () {
        readStream.resume();
      });
      readStream.addListener('end', function () {
        writeStream.end();
      });
      readStream.addListener('close', function () {
        call();
      });
      readStream.addListener('error', function (err) {
        writeStream.end();
        call(err);
      });
      writeStream.addListener('error', function (err) {
        readStream.destroy();
        call(err);
      });
    }
    exports.pump = exports.deprecate(pump, 'util.pump() is deprecated. Use readableStream.pipe() instead.');
    exports.inherits = function (ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
    exports._extend = function (origin, add) {
      if (!add || typeof add !== 'object')
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  });
  require.define('/lib/pdfanno.js', function (module, exports, __dirname, __filename) {
    var nodeUtil = require('/lib/util.js', module), _ = require('/node_modules/underscore/underscore.js', module), PDFUnit = require('/lib/pdfunit.js', module);
    var PDFAnno = function PDFAnnoClosure() {
        'use strict';
        function setupRadioButton(annotation, item) {
          var asName = '';
          var po = annotation.get('Parent');
          if (po) {
            po.forEach(function (key, val) {
              if (key === 'DV') {
                asName = val.name || '';
              } else if (key === 'TU') {
                item.alternativeText = val;
              }
            });
          }
          var ap = annotation.get('AP');
          var nVal = ap.get('N');
          nVal.forEach(function (key, value) {
            if (key.toLowerCase() != 'off') {
              item.value = key;
              item.checked = key === asName;
            }
          });
          if (!item.value)
            item.value = 'off';
        }
        function setupPushButton(annotation, item) {
          var mk = annotation.get('MK');
          item.value = mk.get('CA') || '';
          item.FL = '';
          var ap = annotation.get('A');
          if (ap) {
            var sp = ap.get('S');
            item.FL = ap.get(sp.name);
          }
        }
        function setupCheckBox(annotation, item) {
          var ap = annotation.get('AP');
          var nVal = ap.get('N');
          var i = 0;
          nVal.forEach(function (key, value) {
            i++;
            if (i == 1)
              item.value = key;
          });
        }
        function setupDropDown(annotation, item) {
          item.value = annotation.get('Opt') || [];
        }
        function setupFieldAttributes(annotation, item) {
          var aa = annotation.get('AA');
          if (!aa) {
            return;
          }
          var nVal = aa.get('F');
          if (!nVal) {
            nVal = aa.get('K');
            if (!nVal)
              return;
          }
          nVal.forEach(function (key, value) {
            if (key === 'JS') {
              processFieldAttribute(value, item);
            }
          });
        }
        var AFSpecial_Format = [
            'zip',
            'zip',
            'phone',
            'ssn',
            ''
          ];
        function processFieldAttribute(jsFuncName, item) {
          if (item.hasOwnProperty('TName'))
            return;
          var vParts = jsFuncName.split('(');
          if (vParts.length !== 2)
            return;
          var funcName = vParts[0];
          var funcParam = vParts[1].split(')')[0];
          switch (funcName) {
          case 'AFSpecial_Format':
            item.TName = AFSpecial_Format[Number(funcParam)];
            break;
          case 'AFNumber_Format':
            item.TName = 'number';
            break;
          case 'AFDate_FormatEx':
            item.TName = 'date';
            item.MV = funcParam.replace(/^'+|^"+|'+$|"+$/g, '');
            break;
          case 'AFSpecial_KeystrokeEx':
            var maskValue = funcParam.replace(/^'+|^"+|'+$|"+$/g, '');
            if (!!maskValue && maskValue.length > 0 && maskValue.length < 64) {
              item.TName = 'mask';
              item.MV = maskValue;
            }
            break;
          case 'AFPercent_Format':
            item.TName = 'percent';
            break;
          }
        }
        var _nextId = 1;
        var _name = 'PDFAnno';
        var cls = function (field, viewport, Fields, Boxsets) {
          var _id = _nextId++;
          this.get_id = function () {
            return _id;
          };
          this.get_name = function () {
            return _name + _id;
          };
        };
        cls.prototype.clean = function () {
          delete this.get_id;
          delete this.get_name;
        };
        cls.get_nextId = function () {
          return _name + _nextId;
        };
        cls.processAnnotation = function (annotation, item) {
          if (item.fieldType == 'Btn') {
            if (item.fieldFlags & 32768) {
              setupRadioButton(annotation, item);
            } else if (item.fieldFlags & 65536) {
              setupPushButton(annotation, item);
            } else {
              setupCheckBox(annotation, item);
            }
          } else if (item.fieldType == 'Ch') {
            setupDropDown(annotation, item);
          } else if (item.fieldType == 'Tx') {
            setupFieldAttributes(annotation, item);
          }
        };
        return cls;
      }();
    module.exports = PDFAnno;
  });
  require.define('/lib/pdfunit.js', function (module, exports, __dirname, __filename) {
    var _ = require('/node_modules/underscore/underscore.js', module);
    var PDFUnit = function PFPUnitClosure() {
        'use strict';
        var _nextId = 1;
        var _name = 'PDFUnit';
        var dpi = 96;
        var gridXPerInch = 11;
        var gridYPerInch = 4;
        var _pixelXPerGrid = dpi / gridXPerInch;
        var _pixelYPerGrid = dpi / gridYPerInch;
        var _pixelPerPoint = dpi / 72;
        var kColors = [
            '#000000',
            '#ffffff',
            '#4c4c4c',
            '#808080',
            '#999999',
            '#c0c0c0',
            '#cccccc',
            '#e5e5e5',
            '#f2f2f2',
            '#008000',
            '#00ff00',
            '#bfffa0',
            '#ffd629',
            '#ff99cc',
            '#004080',
            '#9fc0e1',
            '#5580ff',
            '#a9c9fa',
            '#ff0080',
            '#800080',
            '#ffbfff',
            '#e45b21',
            '#ffbfaa',
            '#008080',
            '#ff0000',
            '#fdc59f',
            '#808000',
            '#bfbf00',
            '#824100',
            '#007256',
            '#008000',
            '#000080',
            '#008080',
            '#800080',
            '#ff0000',
            '#0000ff',
            '#008000',
            '#000000'
          ];
        var cls = function () {
          var _id = _nextId++;
          this.get_id = function () {
            return _id;
          };
          this.get_name = function () {
            return _name + _id;
          };
        };
        cls.get_nextId = function () {
          return _name + _nextId;
        };
        cls.toFixedFloat = function (fNum) {
          return parseFloat(fNum.toFixed(3));
        };
        cls.colorCount = function () {
          return kColors.length;
        };
        cls.toPixelX = function (formX) {
          return Math.round(formX * _pixelXPerGrid);
        };
        cls.toPixelY = function (formY) {
          return Math.round(formY * _pixelYPerGrid);
        };
        cls.pointToPixel = function (point) {
          return point * _pixelPerPoint;
        };
        cls.getColorByIndex = function (clrId) {
          return this.kColors[clrId];
        };
        cls.toFormPoint = function (viewportX, viewportY) {
          return [
            viewportX / _pixelXPerGrid,
            viewportY / _pixelYPerGrid
          ];
        };
        cls.toFormX = function (viewportX) {
          return cls.toFixedFloat(viewportX / _pixelXPerGrid);
        };
        cls.toFormY = function (viewportY) {
          return cls.toFixedFloat(viewportY / _pixelYPerGrid);
        };
        cls.findColorIndex = function (color) {
          if (color.length === 4)
            color += '000';
          return kColors.indexOf(color);
        };
        return cls;
      }();
    module.exports = PDFUnit;
  });
  require.define('/node_modules/underscore/underscore.js', function (module, exports, __dirname, __filename) {
    (function () {
      var root = this;
      var previousUnderscore = root._;
      var breaker = {};
      var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
      var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
      var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
      var _ = function (obj) {
        if (obj instanceof _)
          return obj;
        if (!(this instanceof _))
          return new _(obj);
        this._wrapped = obj;
      };
      if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = _;
        }
        exports._ = _;
      } else {
        root._ = _;
      }
      _.VERSION = '1.4.4';
      var each = _.each = _.forEach = function (obj, iterator, context) {
          if (obj == null)
            return;
          if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
          } else if (obj.length === +obj.length) {
            for (var i = 0, l = obj.length; i < l; i++) {
              if (iterator.call(context, obj[i], i, obj) === breaker)
                return;
            }
          } else {
            for (var key in obj) {
              if (_.has(obj, key)) {
                if (iterator.call(context, obj[key], key, obj) === breaker)
                  return;
              }
            }
          }
        };
      _.map = _.collect = function (obj, iterator, context) {
        var results = [];
        if (obj == null)
          return results;
        if (nativeMap && obj.map === nativeMap)
          return obj.map(iterator, context);
        each(obj, function (value, index, list) {
          results[results.length] = iterator.call(context, value, index, list);
        });
        return results;
      };
      var reduceError = 'Reduce of empty array with no initial value';
      _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null)
          obj = [];
        if (nativeReduce && obj.reduce === nativeReduce) {
          if (context)
            iterator = _.bind(iterator, context);
          return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }
        each(obj, function (value, index, list) {
          if (!initial) {
            memo = value;
            initial = true;
          } else {
            memo = iterator.call(context, memo, value, index, list);
          }
        });
        if (!initial)
          throw new TypeError(reduceError);
        return memo;
      };
      _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null)
          obj = [];
        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
          if (context)
            iterator = _.bind(iterator, context);
          return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
        }
        var length = obj.length;
        if (length !== +length) {
          var keys = _.keys(obj);
          length = keys.length;
        }
        each(obj, function (value, index, list) {
          index = keys ? keys[--length] : --length;
          if (!initial) {
            memo = obj[index];
            initial = true;
          } else {
            memo = iterator.call(context, memo, obj[index], index, list);
          }
        });
        if (!initial)
          throw new TypeError(reduceError);
        return memo;
      };
      _.find = _.detect = function (obj, iterator, context) {
        var result;
        any(obj, function (value, index, list) {
          if (iterator.call(context, value, index, list)) {
            result = value;
            return true;
          }
        });
        return result;
      };
      _.filter = _.select = function (obj, iterator, context) {
        var results = [];
        if (obj == null)
          return results;
        if (nativeFilter && obj.filter === nativeFilter)
          return obj.filter(iterator, context);
        each(obj, function (value, index, list) {
          if (iterator.call(context, value, index, list))
            results[results.length] = value;
        });
        return results;
      };
      _.reject = function (obj, iterator, context) {
        return _.filter(obj, function (value, index, list) {
          return !iterator.call(context, value, index, list);
        }, context);
      };
      _.every = _.all = function (obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = true;
        if (obj == null)
          return result;
        if (nativeEvery && obj.every === nativeEvery)
          return obj.every(iterator, context);
        each(obj, function (value, index, list) {
          if (!(result = result && iterator.call(context, value, index, list)))
            return breaker;
        });
        return !!result;
      };
      var any = _.some = _.any = function (obj, iterator, context) {
          iterator || (iterator = _.identity);
          var result = false;
          if (obj == null)
            return result;
          if (nativeSome && obj.some === nativeSome)
            return obj.some(iterator, context);
          each(obj, function (value, index, list) {
            if (result || (result = iterator.call(context, value, index, list)))
              return breaker;
          });
          return !!result;
        };
      _.contains = _.include = function (obj, target) {
        if (obj == null)
          return false;
        if (nativeIndexOf && obj.indexOf === nativeIndexOf)
          return obj.indexOf(target) != -1;
        return any(obj, function (value) {
          return value === target;
        });
      };
      _.invoke = function (obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function (value) {
          return (isFunc ? method : value[method]).apply(value, args);
        });
      };
      _.pluck = function (obj, key) {
        return _.map(obj, function (value) {
          return value[key];
        });
      };
      _.where = function (obj, attrs, first) {
        if (_.isEmpty(attrs))
          return first ? null : [];
        return _[first ? 'find' : 'filter'](obj, function (value) {
          for (var key in attrs) {
            if (attrs[key] !== value[key])
              return false;
          }
          return true;
        });
      };
      _.findWhere = function (obj, attrs) {
        return _.where(obj, attrs, true);
      };
      _.max = function (obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
          return Math.max.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj))
          return -Infinity;
        var result = {
            computed: -Infinity,
            value: -Infinity
          };
        each(obj, function (value, index, list) {
          var computed = iterator ? iterator.call(context, value, index, list) : value;
          computed >= result.computed && (result = {
            value: value,
            computed: computed
          });
        });
        return result.value;
      };
      _.min = function (obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
          return Math.min.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj))
          return Infinity;
        var result = {
            computed: Infinity,
            value: Infinity
          };
        each(obj, function (value, index, list) {
          var computed = iterator ? iterator.call(context, value, index, list) : value;
          computed < result.computed && (result = {
            value: value,
            computed: computed
          });
        });
        return result.value;
      };
      _.shuffle = function (obj) {
        var rand;
        var index = 0;
        var shuffled = [];
        each(obj, function (value) {
          rand = _.random(index++);
          shuffled[index - 1] = shuffled[rand];
          shuffled[rand] = value;
        });
        return shuffled;
      };
      var lookupIterator = function (value) {
        return _.isFunction(value) ? value : function (obj) {
          return obj[value];
        };
      };
      _.sortBy = function (obj, value, context) {
        var iterator = lookupIterator(value);
        return _.pluck(_.map(obj, function (value, index, list) {
          return {
            value: value,
            index: index,
            criteria: iterator.call(context, value, index, list)
          };
        }).sort(function (left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0)
              return 1;
            if (a < b || b === void 0)
              return -1;
          }
          return left.index < right.index ? -1 : 1;
        }), 'value');
      };
      var group = function (obj, value, context, behavior) {
        var result = {};
        var iterator = lookupIterator(value || _.identity);
        each(obj, function (value, index) {
          var key = iterator.call(context, value, index, obj);
          behavior(result, key, value);
        });
        return result;
      };
      _.groupBy = function (obj, value, context) {
        return group(obj, value, context, function (result, key, value) {
          (_.has(result, key) ? result[key] : result[key] = []).push(value);
        });
      };
      _.countBy = function (obj, value, context) {
        return group(obj, value, context, function (result, key) {
          if (!_.has(result, key))
            result[key] = 0;
          result[key]++;
        });
      };
      _.sortedIndex = function (array, obj, iterator, context) {
        iterator = iterator == null ? _.identity : lookupIterator(iterator);
        var value = iterator.call(context, obj);
        var low = 0, high = array.length;
        while (low < high) {
          var mid = low + high >>> 1;
          iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
      };
      _.toArray = function (obj) {
        if (!obj)
          return [];
        if (_.isArray(obj))
          return slice.call(obj);
        if (obj.length === +obj.length)
          return _.map(obj, _.identity);
        return _.values(obj);
      };
      _.size = function (obj) {
        if (obj == null)
          return 0;
        return obj.length === +obj.length ? obj.length : _.keys(obj).length;
      };
      _.first = _.head = _.take = function (array, n, guard) {
        if (array == null)
          return void 0;
        return n != null && !guard ? slice.call(array, 0, n) : array[0];
      };
      _.initial = function (array, n, guard) {
        return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
      };
      _.last = function (array, n, guard) {
        if (array == null)
          return void 0;
        if (n != null && !guard) {
          return slice.call(array, Math.max(array.length - n, 0));
        } else {
          return array[array.length - 1];
        }
      };
      _.rest = _.tail = _.drop = function (array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
      };
      _.compact = function (array) {
        return _.filter(array, _.identity);
      };
      var flatten = function (input, shallow, output) {
        each(input, function (value) {
          if (_.isArray(value)) {
            shallow ? push.apply(output, value) : flatten(value, shallow, output);
          } else {
            output.push(value);
          }
        });
        return output;
      };
      _.flatten = function (array, shallow) {
        return flatten(array, shallow, []);
      };
      _.without = function (array) {
        return _.difference(array, slice.call(arguments, 1));
      };
      _.uniq = _.unique = function (array, isSorted, iterator, context) {
        if (_.isFunction(isSorted)) {
          context = iterator;
          iterator = isSorted;
          isSorted = false;
        }
        var initial = iterator ? _.map(array, iterator, context) : array;
        var results = [];
        var seen = [];
        each(initial, function (value, index) {
          if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
            seen.push(value);
            results.push(array[index]);
          }
        });
        return results;
      };
      _.union = function () {
        return _.uniq(concat.apply(ArrayProto, arguments));
      };
      _.intersection = function (array) {
        var rest = slice.call(arguments, 1);
        return _.filter(_.uniq(array), function (item) {
          return _.every(rest, function (other) {
            return _.indexOf(other, item) >= 0;
          });
        });
      };
      _.difference = function (array) {
        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
        return _.filter(array, function (value) {
          return !_.contains(rest, value);
        });
      };
      _.zip = function () {
        var args = slice.call(arguments);
        var length = _.max(_.pluck(args, 'length'));
        var results = new Array(length);
        for (var i = 0; i < length; i++) {
          results[i] = _.pluck(args, '' + i);
        }
        return results;
      };
      _.object = function (list, values) {
        if (list == null)
          return {};
        var result = {};
        for (var i = 0, l = list.length; i < l; i++) {
          if (values) {
            result[list[i]] = values[i];
          } else {
            result[list[i][0]] = list[i][1];
          }
        }
        return result;
      };
      _.indexOf = function (array, item, isSorted) {
        if (array == null)
          return -1;
        var i = 0, l = array.length;
        if (isSorted) {
          if (typeof isSorted == 'number') {
            i = isSorted < 0 ? Math.max(0, l + isSorted) : isSorted;
          } else {
            i = _.sortedIndex(array, item);
            return array[i] === item ? i : -1;
          }
        }
        if (nativeIndexOf && array.indexOf === nativeIndexOf)
          return array.indexOf(item, isSorted);
        for (; i < l; i++)
          if (array[i] === item)
            return i;
        return -1;
      };
      _.lastIndexOf = function (array, item, from) {
        if (array == null)
          return -1;
        var hasIndex = from != null;
        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
          return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
        }
        var i = hasIndex ? from : array.length;
        while (i--)
          if (array[i] === item)
            return i;
        return -1;
      };
      _.range = function (start, stop, step) {
        if (arguments.length <= 1) {
          stop = start || 0;
          start = 0;
        }
        step = arguments[2] || 1;
        var len = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(len);
        while (idx < len) {
          range[idx++] = start;
          start += step;
        }
        return range;
      };
      _.bind = function (func, context) {
        if (func.bind === nativeBind && nativeBind)
          return nativeBind.apply(func, slice.call(arguments, 1));
        var args = slice.call(arguments, 2);
        return function () {
          return func.apply(context, args.concat(slice.call(arguments)));
        };
      };
      _.partial = function (func) {
        var args = slice.call(arguments, 1);
        return function () {
          return func.apply(this, args.concat(slice.call(arguments)));
        };
      };
      _.bindAll = function (obj) {
        var funcs = slice.call(arguments, 1);
        if (funcs.length === 0)
          funcs = _.functions(obj);
        each(funcs, function (f) {
          obj[f] = _.bind(obj[f], obj);
        });
        return obj;
      };
      _.memoize = function (func, hasher) {
        var memo = {};
        hasher || (hasher = _.identity);
        return function () {
          var key = hasher.apply(this, arguments);
          return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
        };
      };
      _.delay = function (func, wait) {
        var args = slice.call(arguments, 2);
        return setABTimeout(function () {
          return func.apply(null, args);
        }, wait);
      };
      _.defer = function (func) {
        return _.delay.apply(_, [
          func,
          1
        ].concat(slice.call(arguments, 1)));
      };
      _.throttle = function (func, wait) {
        var context, args, timeout, result;
        var previous = 0;
        var later = function () {
          previous = new Date;
          timeout = null;
          result = func.apply(context, args);
        };
        return function () {
          var now = new Date;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0) {
            clearABTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
          } else if (!timeout) {
            timeout = setABTimeout(later, remaining);
          }
          return result;
        };
      };
      _.debounce = function (func, wait, immediate) {
        var timeout, result;
        return function () {
          var context = this, args = arguments;
          var later = function () {
            timeout = null;
            if (!immediate)
              result = func.apply(context, args);
          };
          var callNow = immediate && !timeout;
          clearABTimeout(timeout);
          timeout = setABTimeout(later, wait);
          if (callNow)
            result = func.apply(context, args);
          return result;
        };
      };
      _.once = function (func) {
        var ran = false, memo;
        return function () {
          if (ran)
            return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      };
      _.wrap = function (func, wrapper) {
        return function () {
          var args = [func];
          push.apply(args, arguments);
          return wrapper.apply(this, args);
        };
      };
      _.compose = function () {
        var funcs = arguments;
        return function () {
          var args = arguments;
          for (var i = funcs.length - 1; i >= 0; i--) {
            args = [funcs[i].apply(this, args)];
          }
          return args[0];
        };
      };
      _.after = function (times, func) {
        if (times <= 0)
          return func();
        return function () {
          if (--times < 1) {
            return func.apply(this, arguments);
          }
        };
      };
      _.keys = nativeKeys || function (obj) {
        if (obj !== Object(obj))
          throw new TypeError('Invalid object');
        var keys = [];
        for (var key in obj)
          if (_.has(obj, key))
            keys[keys.length] = key;
        return keys;
      };
      _.values = function (obj) {
        var values = [];
        for (var key in obj)
          if (_.has(obj, key))
            values.push(obj[key]);
        return values;
      };
      _.pairs = function (obj) {
        var pairs = [];
        for (var key in obj)
          if (_.has(obj, key))
            pairs.push([
              key,
              obj[key]
            ]);
        return pairs;
      };
      _.invert = function (obj) {
        var result = {};
        for (var key in obj)
          if (_.has(obj, key))
            result[obj[key]] = key;
        return result;
      };
      _.functions = _.methods = function (obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key]))
            names.push(key);
        }
        return names.sort();
      };
      _.extend = function (obj) {
        each(slice.call(arguments, 1), function (source) {
          if (source) {
            for (var prop in source) {
              obj[prop] = source[prop];
            }
          }
        });
        return obj;
      };
      _.pick = function (obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        each(keys, function (key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      };
      _.omit = function (obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        for (var key in obj) {
          if (!_.contains(keys, key))
            copy[key] = obj[key];
        }
        return copy;
      };
      _.defaults = function (obj) {
        each(slice.call(arguments, 1), function (source) {
          if (source) {
            for (var prop in source) {
              if (obj[prop] == null)
                obj[prop] = source[prop];
            }
          }
        });
        return obj;
      };
      _.clone = function (obj) {
        if (!_.isObject(obj))
          return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
      };
      _.tap = function (obj, interceptor) {
        interceptor(obj);
        return obj;
      };
      var eq = function (a, b, aStack, bStack) {
        if (a === b)
          return a !== 0 || 1 / a == 1 / b;
        if (a == null || b == null)
          return a === b;
        if (a instanceof _)
          a = a._wrapped;
        if (b instanceof _)
          b = b._wrapped;
        var className = toString.call(a);
        if (className != toString.call(b))
          return false;
        switch (className) {
        case '[object String]':
          return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != 'object' || typeof b != 'object')
          return false;
        var length = aStack.length;
        while (length--) {
          if (aStack[length] == a)
            return bStack[length] == b;
        }
        aStack.push(a);
        bStack.push(b);
        var size = 0, result = true;
        if (className == '[object Array]') {
          size = a.length;
          result = size == b.length;
          if (result) {
            while (size--) {
              if (!(result = eq(a[size], b[size], aStack, bStack)))
                break;
            }
          }
        } else {
          var aCtor = a.constructor, bCtor = b.constructor;
          if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {
            return false;
          }
          for (var key in a) {
            if (_.has(a, key)) {
              size++;
              if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)))
                break;
            }
          }
          if (result) {
            for (key in b) {
              if (_.has(b, key) && !size--)
                break;
            }
            result = !size;
          }
        }
        aStack.pop();
        bStack.pop();
        return result;
      };
      _.isEqual = function (a, b) {
        return eq(a, b, [], []);
      };
      _.isEmpty = function (obj) {
        if (obj == null)
          return true;
        if (_.isArray(obj) || _.isString(obj))
          return obj.length === 0;
        for (var key in obj)
          if (_.has(obj, key))
            return false;
        return true;
      };
      _.isElement = function (obj) {
        return !!(obj && obj.nodeType === 1);
      };
      _.isArray = nativeIsArray || function (obj) {
        return toString.call(obj) == '[object Array]';
      };
      _.isObject = function (obj) {
        return obj === Object(obj);
      };
      each([
        'Arguments',
        'Function',
        'String',
        'Number',
        'Date',
        'RegExp'
      ], function (name) {
        _['is' + name] = function (obj) {
          return toString.call(obj) == '[object ' + name + ']';
        };
      });
      if (!_.isArguments(arguments)) {
        _.isArguments = function (obj) {
          return !!(obj && _.has(obj, 'callee'));
        };
      }
      if (typeof /./ !== 'function') {
        _.isFunction = function (obj) {
          return typeof obj === 'function';
        };
      }
      _.isFinite = function (obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
      };
      _.isNaN = function (obj) {
        return _.isNumber(obj) && obj != +obj;
      };
      _.isBoolean = function (obj) {
        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
      };
      _.isNull = function (obj) {
        return obj === null;
      };
      _.isUndefined = function (obj) {
        return obj === void 0;
      };
      _.has = function (obj, key) {
        return hasOwnProperty.call(obj, key);
      };
      _.noConflict = function () {
        root._ = previousUnderscore;
        return this;
      };
      _.identity = function (value) {
        return value;
      };
      _.times = function (n, iterator, context) {
        var accum = Array(n);
        for (var i = 0; i < n; i++)
          accum[i] = iterator.call(context, i);
        return accum;
      };
      _.random = function (min, max) {
        if (max == null) {
          max = min;
          min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
      };
      var entityMap = {
          escape: {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;',
            '/': '&#x2F;'
          }
        };
      entityMap.unescape = _.invert(entityMap.escape);
      var entityRegexes = {
          escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
          unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
        };
      _.each([
        'escape',
        'unescape'
      ], function (method) {
        _[method] = function (string) {
          if (string == null)
            return '';
          return ('' + string).replace(entityRegexes[method], function (match) {
            return entityMap[method][match];
          });
        };
      });
      _.result = function (object, property) {
        if (object == null)
          return null;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
      };
      _.mixin = function (obj) {
        each(_.functions(obj), function (name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function () {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return result.call(this, func.apply(_, args));
          };
        });
      };
      var idCounter = 0;
      _.uniqueId = function (prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      };
      _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      };
      var noMatch = /(.)^/;
      var escapes = {
          "'": "'",
          '\\': '\\',
          '\r': 'r',
          '\n': 'n',
          '\t': 't',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
      _.template = function (text, data, settings) {
        var render;
        settings = _.defaults({}, settings, _.templateSettings);
        var matcher = new RegExp([
            (settings.escape || noMatch).source,
            (settings.interpolate || noMatch).source,
            (settings.evaluate || noMatch).source
          ].join('|') + '|$', 'g');
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escaper, function (match) {
            return '\\' + escapes[match];
          });
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          }
          if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          }
          if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        if (!settings.variable)
          source = 'with(obj||{}){\n' + source + '}\n';
        source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
        try {
          render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }
        if (data)
          return render(data, _);
        var template = function (data) {
          return render.call(this, data, _);
        };
        template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
        return template;
      };
      _.chain = function (obj) {
        return _(obj).chain();
      };
      var result = function (obj) {
        return this._chain ? _(obj).chain() : obj;
      };
      _.mixin(_);
      each([
        'pop',
        'push',
        'reverse',
        'shift',
        'sort',
        'splice',
        'unshift'
      ], function (name) {
        var method = ArrayProto[name];
        _.prototype[name] = function () {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name == 'shift' || name == 'splice') && obj.length === 0)
            delete obj[0];
          return result.call(this, obj);
        };
      });
      each([
        'concat',
        'join',
        'slice'
      ], function (name) {
        var method = ArrayProto[name];
        _.prototype[name] = function () {
          return result.call(this, method.apply(this._wrapped, arguments));
        };
      });
      _.extend(_.prototype, {
        chain: function () {
          this._chain = true;
          return this;
        },
        value: function () {
          return this._wrapped;
        }
      });
    }.call(this));
  });
  require.define('/lib/util.js', function (module, exports, __dirname, __filename) {
    var PseudoUtils = function () {
        return {
          inherits: function (ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      }();
    module.exports = PseudoUtils;
  });
  require.define('/lib/pdffield.js', function (module, exports, __dirname, __filename) {
    var nodeUtil = require('/lib/util.js', module), _ = require('/node_modules/underscore/underscore.js', module), PDFUnit = require('/lib/pdfunit.js', module);
    var PDFField = function PDFFieldClosure() {
        'use strict';
        var _nextId = 1;
        var _name = 'PDFField';
        var _tabIndex = 0;
        var kFBANotOverridable = 1024;
        var kFBARequired = 16;
        var kMinHeight = 20;
        var cls = function (field, viewport, Fields, Boxsets) {
          var _id = _nextId++;
          this.get_id = function () {
            return _id;
          };
          this.get_name = function () {
            return _name + _id;
          };
          this.field = field;
          this.viewport = viewport;
          this.Fields = Fields;
          this.Boxsets = Boxsets;
        };
        var _normalizeRect = function (rect) {
          var r = rect.slice(0);
          if (rect[0] > rect[2]) {
            r[0] = rect[2];
            r[2] = rect[0];
          }
          if (rect[1] > rect[3]) {
            r[1] = rect[3];
            r[3] = rect[1];
          }
          return r;
        };
        cls.get_nextId = function () {
          return _name + _nextId;
        };
        cls.isWidgetSupported = function (field) {
          var retVal = false;
          switch (field.fieldType) {
          case 'Tx':
            retVal = true;
            break;
          case 'Btn':
            if (field.fieldFlags & 32768) {
              field.fieldType = 'Rd';
            } else if (field.fieldFlags & 65536) {
              field.fieldType = 'Btn';
            } else {
              field.fieldType = 'Cb';
            }
            retVal = true;
            break;
          case 'Ch':
            retVal = true;
            break;
          default:
            nodeUtil.p2jwarn('Unsupported: field.fieldType of ' + field.fieldType);
            break;
          }
          return retVal;
        };
        cls.isFormElement = function (field) {
          var retVal = false;
          switch (field.subtype) {
          case 'Widget':
            retVal = cls.isWidgetSupported(field);
            break;
          default:
            nodeUtil.p2jwarn('Unsupported: field.type of ' + field.subtype);
            break;
          }
          return retVal;
        };
        var _getFieldPosition = function (field) {
          var viewPort = this.viewport;
          var fieldRect = viewPort.convertToViewportRectangle(field.rect);
          var rect = _normalizeRect(fieldRect);
          var height = rect[3] - rect[1];
          if (field.fieldType === 'Tx') {
            if (height > kMinHeight + 2) {
              rect[1] += 2;
              height -= 2;
            }
          } else if (field.fieldType !== 'Ch') {
            rect[1] -= 3;
          }
          height = height >= kMinHeight ? height : kMinHeight;
          return {
            x: PDFUnit.toFormX(rect[0]),
            y: PDFUnit.toFormY(rect[1]),
            w: PDFUnit.toFormX(rect[2] - rect[0]),
            h: PDFUnit.toFormY(height)
          };
        };
        var _getFieldBaseData = function (field) {
          var attributeMask = 0;
          if (field.fieldFlags & 1) {
            attributeMask |= kFBANotOverridable;
          }
          if (field.fieldFlags & 2) {
            attributeMask |= kFBARequired;
          }
          var anData = {
              id: {
                Id: field.fullName,
                EN: 0
              },
              TI: field.TI,
              AM: attributeMask
            };
          if (field.alternativeText && field.alternativeText.length > 1) {
            anData.TU = field.alternativeText;
          }
          return _.extend(anData, _getFieldPosition.call(this, field));
        };
        var _addAlpha = function (field) {
          var anData = _.extend({
              style: 48,
              T: {
                Name: field.TName || 'alpha',
                TypeInfo: {}
              }
            }, _getFieldBaseData.call(this, field));
          if (field.MV) {
            anData.MV = field.MV;
          }
          if (field.fieldValue) {
            anData.V = field.fieldValue;
          }
          this.Fields.push(anData);
        };
        var _addCheckBox = function (box) {
          var anData = _.extend({
              style: 48,
              T: {
                Name: 'box',
                TypeInfo: {}
              }
            }, _getFieldBaseData.call(this, box));
          this.Boxsets.push({ boxes: [anData] });
        };
        var _addRadioButton = function (box) {
          var anData = _.extend({
              style: 48,
              T: {
                Name: 'box',
                TypeInfo: {}
              }
            }, _getFieldBaseData.call(this, box));
          anData.id.Id = box.value;
          if (_.has(box, 'checked')) {
            anData.checked = box.checked;
          }
          var rdGroup = _.find(this.Boxsets, function (boxset) {
              return _.has(boxset, 'id') && _.has(boxset.id, 'Id') && boxset.id.Id === box.fullName;
            });
          if (!!rdGroup && _.has(rdGroup, 'boxes')) {
            rdGroup.boxes.push(anData);
          } else {
            this.Boxsets.push({
              boxes: [anData],
              id: {
                Id: box.fullName,
                EN: 0
              }
            });
          }
        };
        var _addLinkButton = function (field) {
          var anData = _.extend({
              style: 48,
              T: { Name: 'link' },
              FL: { form: { Id: field.FL } }
            }, _getFieldBaseData.call(this, field));
          this.Fields.push(anData);
        };
        var _addSelect = function (field) {
          var anData = _.extend({
              style: 48,
              T: {
                Name: 'alpha',
                TypeInfo: {}
              }
            }, _getFieldBaseData.call(this, field));
          anData.w -= .5;
          anData.PL = {
            V: [],
            D: []
          };
          _.each(field.value, function (ele, idx) {
            anData.PL.D.push(ele[0]);
            anData.PL.V.push(ele[1]);
          });
          this.Fields.push(anData);
        };
        cls.prototype.processField = function () {
          this.field.TI = _tabIndex++;
          switch (this.field.fieldType) {
          case 'Tx':
            _addAlpha.call(this, this.field);
            break;
          case 'Cb':
            _addCheckBox.call(this, this.field);
            break;
          case 'Rd':
            _addRadioButton.call(this, this.field);
            break;
          case 'Btn':
            _addLinkButton.call(this, this.field);
            break;
          case 'Ch':
            _addSelect.call(this, this.field);
            break;
          }
          this.clean();
        };
        cls.prototype.clean = function () {
          delete this.get_id;
          delete this.get_name;
          delete this.field;
          delete this.viewport;
          delete this.Fields;
          delete this.Boxsets;
        };
        cls.getAllFieldsTypes = function (data) {
          function isFieldReadOnly(field) {
            return field.AM & kFBANotOverridable ? true : false;
          }
          function getFieldBase(field) {
            return {
              id: field.id.Id,
              type: field.T.Name,
              calc: isFieldReadOnly(field),
              value: field.V || ''
            };
          }
          var retVal = [];
          _.each(data.Pages, function (page) {
            _.each(page.Boxsets, function (boxsets) {
              if (boxsets.boxes.length > 1) {
                _.each(boxsets.boxes, function (box) {
                  retVal.push({
                    id: boxsets.id.Id,
                    type: 'radio',
                    calc: isFieldReadOnly(box),
                    value: box.id.Id
                  });
                });
              } else {
                retVal.push(getFieldBase(boxsets.boxes[0]));
              }
            });
            _.each(page.Fields, function (field) {
              retVal.push(getFieldBase(field));
            });
          });
          return retVal;
        };
        return cls;
      }();
    module.exports = PDFField;
  });
  require.define('/lib/pdfcanvas.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var nodeUtil = require('/lib/util.js', module), _ = require('/node_modules/underscore/underscore.js', module), PDFLine = require('/lib/pdfline.js', module), PDFFill = require('/lib/pdffill.js', module), PDFFont = require('/lib/pdffont.js', module);
    (function () {
      var _nextId = 1;
      var _name = 'PDFCanvas';
      var m = Math;
      var mr = m.round;
      var ms = m.sin;
      var mc = m.cos;
      var abs = m.abs;
      var sqrt = m.sqrt;
      var dec2hex = [];
      for (var i = 0; i < 16; i++) {
        for (var j = 0; j < 16; j++) {
          dec2hex[i * 16 + j] = i.toString(16) + j.toString(16);
        }
      }
      function createMatrixIdentity() {
        return [
          [
            1,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ]
        ];
      }
      function matrixMultiply(m1, m2) {
        var result = createMatrixIdentity();
        for (var x = 0; x < 3; x++) {
          for (var y = 0; y < 3; y++) {
            var sum = 0;
            for (var z = 0; z < 3; z++) {
              sum += m1[x][z] * m2[z][y];
            }
            result[x][y] = sum;
          }
        }
        return result;
      }
      function copyState(o1, o2) {
        o2.fillStyle = o1.fillStyle;
        o2.lineCap = o1.lineCap;
        o2.lineJoin = o1.lineJoin;
        o2.lineWidth = o1.lineWidth;
        o2.miterLimit = o1.miterLimit;
        o2.shadowBlur = o1.shadowBlur;
        o2.shadowColor = o1.shadowColor;
        o2.shadowOffsetX = o1.shadowOffsetX;
        o2.shadowOffsetY = o1.shadowOffsetY;
        o2.strokeStyle = o1.strokeStyle;
        o2.globalAlpha = o1.globalAlpha;
        o2.arcScaleX_ = o1.arcScaleX_;
        o2.arcScaleY_ = o1.arcScaleY_;
        o2.lineScale_ = o1.lineScale_;
        o2.dashArray = o1.dashArray;
      }
      function processStyle(styleString) {
        var str, alpha = 1;
        styleString = String(styleString);
        if (styleString.substring(0, 3) == 'rgb') {
          var start = styleString.indexOf('(', 3);
          var end = styleString.indexOf(')', start + 1);
          var guts = styleString.substring(start + 1, end).split(',');
          str = '#';
          for (var i = 0; i < 3; i++) {
            str += dec2hex[Number(guts[i])];
          }
          if (guts.length == 4 && styleString.substr(3, 1) == 'a') {
            alpha = guts[3];
          }
        } else {
          str = styleString;
        }
        return {
          color: str,
          alpha: alpha
        };
      }
      function processLineCap(lineCap) {
        switch (lineCap) {
        case 'butt':
          return 'flat';
        case 'round':
          return 'round';
        case 'square':
        default:
          return 'square';
        }
      }
      function CanvasRenderingContext2D_(canvasTarget, scaledWidth, scaledHeight) {
        var _id = _nextId++;
        this.get_id = function () {
          return _id;
        };
        this.get_name = function () {
          return _name + _id;
        };
        this.m_ = createMatrixIdentity();
        this.mStack_ = [];
        this.aStack_ = [];
        this.currentPath_ = [];
        this.strokeStyle = '#000';
        this.fillStyle = '#000';
        this.lineWidth = 1;
        this.lineJoin = 'miter';
        this.lineCap = 'butt';
        this.dashArray = [];
        this.miterLimit = 1;
        this.globalAlpha = 1;
        if (!_.has(canvasTarget, 'HLines') || !_.isArray(canvasTarget.HLines))
          canvasTarget.HLines = [];
        if (!_.has(canvasTarget, 'VLines') || !_.isArray(canvasTarget.VLines))
          canvasTarget.VLines = [];
        if (!_.has(canvasTarget, 'Fills') || !_.isArray(canvasTarget.Fills))
          canvasTarget.Fills = [];
        if (!_.has(canvasTarget, 'Texts') || !_.isArray(canvasTarget.Texts))
          canvasTarget.Texts = [];
        this.canvas = canvasTarget;
        this.width = scaledWidth;
        this.height = scaledHeight;
        this.arcScaleX_ = 1;
        this.arcScaleY_ = 1;
        this.lineScale_ = 1;
        this.currentFont = null;
      }
      var _drawPDFLine = function (p1, p2, lineWidth, color) {
        var dashedLine = _.isArray(this.dashArray) && this.dashArray.length > 1;
        var pL = new PDFLine(p1.x, p1.y, p2.x, p2.y, lineWidth, color, dashedLine);
        pL.processLine(this.canvas);
      };
      var _drawPDFFill = function (cp, min, max, color) {
        var width = max.x - min.x;
        var height = max.y - min.y;
        var pF = new PDFFill(cp.x, cp.y, width, height, color);
        pF.processFill(this.canvas);
      };
      var _needRemoveRect = function (x, y, w, h) {
        var retVal = Math.abs(w - Math.abs(h)) < 1 && w < 13;
        if (retVal) {
          nodeUtil.p2jinfo('Skipped: tiny rect: w=' + w + ', h=' + h);
        }
        return retVal;
      };
      var contextPrototype = CanvasRenderingContext2D_.prototype;
      contextPrototype.getContext = function (ctxType) {
        return ctxType === '2d' ? this : null;
      };
      contextPrototype.setLineDash = function (lineDash) {
        this.dashArray = lineDash;
      };
      contextPrototype.getLineDash = function () {
        return this.dashArray;
      };
      contextPrototype.fillText = function (text, x, y, maxWidth, fontSize) {
        if (!text || text.trim().length < 1)
          return;
        var p = this.getCoords_(x, y);
        var a = processStyle(this.fillStyle || this.strokeStyle);
        var color = !!a ? a.color : '#000000';
        this.currentFont.processText(p, text, maxWidth, color, fontSize, this.canvas, this.m_);
      };
      contextPrototype.strokeText = function (text, x, y, maxWidth) {
        this.fillText(text, x, y, maxWidth);
      };
      contextPrototype.setFont = function (fontObj) {
        if (!!this.currentFont && _.isFunction(this.currentFont.clean)) {
          this.currentFont.clean();
          this.currentFont = null;
        }
        this.currentFont = new PDFFont(fontObj);
      };
      contextPrototype.clearRect = function () {
      };
      contextPrototype.beginPath = function () {
        this.currentPath_ = [];
      };
      contextPrototype.moveTo = function (aX, aY) {
        var p = this.getCoords_(aX, aY);
        this.currentPath_.push({
          type: 'moveTo',
          x: p.x,
          y: p.y
        });
        this.currentX_ = p.x;
        this.currentY_ = p.y;
      };
      contextPrototype.lineTo = function (aX, aY) {
        var p = this.getCoords_(aX, aY);
        this.currentPath_.push({
          type: 'lineTo',
          x: p.x,
          y: p.y
        });
        this.currentX_ = p.x;
        this.currentY_ = p.y;
      };
      contextPrototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        var p = this.getCoords_(aX, aY);
        var cp1 = this.getCoords_(aCP1x, aCP1y);
        var cp2 = this.getCoords_(aCP2x, aCP2y);
        bezierCurveTo(this, cp1, cp2, p);
      };
      function bezierCurveTo(self, cp1, cp2, p) {
        self.currentPath_.push({
          type: 'bezierCurveTo',
          cp1x: cp1.x,
          cp1y: cp1.y,
          cp2x: cp2.x,
          cp2y: cp2.y,
          x: p.x,
          y: p.y
        });
        self.currentX_ = p.x;
        self.currentY_ = p.y;
      }
      contextPrototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
        var cp = this.getCoords_(aCPx, aCPy);
        var p = this.getCoords_(aX, aY);
        var cp1 = {
            x: this.currentX_ + 2 / 3 * (cp.x - this.currentX_),
            y: this.currentY_ + 2 / 3 * (cp.y - this.currentY_)
          };
        var cp2 = {
            x: cp1.x + (p.x - this.currentX_) / 3,
            y: cp1.y + (p.y - this.currentY_) / 3
          };
        bezierCurveTo(this, cp1, cp2, p);
      };
      contextPrototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        var arcType = aClockwise ? 'at' : 'wa';
        var xStart = aX + mc(aStartAngle) * aRadius;
        var yStart = aY + ms(aStartAngle) * aRadius;
        var xEnd = aX + mc(aEndAngle) * aRadius;
        var yEnd = aY + ms(aEndAngle) * aRadius;
        if (xStart == xEnd && !aClockwise) {
          xStart += .125;
        }
        var p = this.getCoords_(aX, aY);
        var pStart = this.getCoords_(xStart, yStart);
        var pEnd = this.getCoords_(xEnd, yEnd);
        this.currentPath_.push({
          type: arcType,
          x: p.x,
          y: p.y,
          radius: aRadius,
          xStart: pStart.x,
          yStart: pStart.y,
          xEnd: pEnd.x,
          yEnd: pEnd.y
        });
      };
      contextPrototype.rect = function (aX, aY, aWidth, aHeight) {
        if (_needRemoveRect.call(this, aX, aY, aWidth, aHeight)) {
          return;
        }
        this.moveTo(aX, aY);
        this.lineTo(aX + aWidth, aY);
        this.lineTo(aX + aWidth, aY + aHeight);
        this.lineTo(aX, aY + aHeight);
        this.closePath();
      };
      contextPrototype.strokeRect = function (aX, aY, aWidth, aHeight) {
        if (_needRemoveRect.call(this, aX, aY, aWidth, aHeight)) {
          return;
        }
        var oldPath = this.currentPath_;
        this.beginPath();
        this.moveTo(aX, aY);
        this.lineTo(aX + aWidth, aY);
        this.lineTo(aX + aWidth, aY + aHeight);
        this.lineTo(aX, aY + aHeight);
        this.closePath();
        this.stroke();
        this.currentPath_ = oldPath;
      };
      contextPrototype.fillRect = function (aX, aY, aWidth, aHeight) {
        if (_needRemoveRect.call(this, aX, aY, aWidth, aHeight)) {
          return;
        }
        var oldPath = this.currentPath_;
        this.beginPath();
        this.moveTo(aX, aY);
        this.lineTo(aX + aWidth, aY);
        this.lineTo(aX + aWidth, aY + aHeight);
        this.lineTo(aX, aY + aHeight);
        this.closePath();
        this.fill();
        this.currentPath_ = oldPath;
      };
      contextPrototype.createLinearGradient = function (aX0, aY0, aX1, aY1) {
        var gradient = new CanvasGradient_('gradient');
        gradient.x0_ = aX0;
        gradient.y0_ = aY0;
        gradient.x1_ = aX1;
        gradient.y1_ = aY1;
        return gradient;
      };
      contextPrototype.createRadialGradient = function (aX0, aY0, aR0, aX1, aY1, aR1) {
        var gradient = new CanvasGradient_('gradientradial');
        gradient.x0_ = aX0;
        gradient.y0_ = aY0;
        gradient.r0_ = aR0;
        gradient.x1_ = aX1;
        gradient.y1_ = aY1;
        gradient.r1_ = aR1;
        return gradient;
      };
      contextPrototype.drawImage = function (image, var_args) {
      };
      contextPrototype.getImageData = function (x, y, w, h) {
        return {
          width: w,
          height: h,
          data: new Uint8Array(w * h * 4)
        };
      };
      contextPrototype.stroke = function (aFill) {
        if (this.currentPath_.length < 2) {
          return;
        }
        var a = processStyle(aFill ? this.fillStyle : this.strokeStyle);
        var color = a.color;
        var lineWidth = this.lineScale_ * this.lineWidth;
        var min = {
            x: null,
            y: null
          };
        var max = {
            x: null,
            y: null
          };
        for (var i = 0; i < this.currentPath_.length; i++) {
          var p = this.currentPath_[i];
          switch (p.type) {
          case 'moveTo':
            break;
          case 'lineTo':
            if (!aFill) {
              if (i > 0) {
                _drawPDFLine.call(this, this.currentPath_[i - 1], p, lineWidth, color);
              }
            }
            break;
          case 'close':
            if (!aFill) {
              if (i > 0) {
                _drawPDFLine.call(this, this.currentPath_[i - 1], this.currentPath_[0], lineWidth, color);
              }
            }
            p = null;
            break;
          case 'bezierCurveTo':
            break;
          case 'at':
          case 'wa':
            break;
          }
          if (aFill && p) {
            if (min.x == null || p.x < min.x) {
              min.x = p.x;
            }
            if (max.x == null || p.x > max.x) {
              max.x = p.x;
            }
            if (min.y == null || p.y < min.y) {
              min.y = p.y;
            }
            if (max.y == null || p.y > max.y) {
              max.y = p.y;
            }
          }
        }
        if (aFill) {
          _drawPDFFill.call(this, min, min, max, color);
        }
      };
      contextPrototype.fill = function () {
        this.stroke(true);
      };
      contextPrototype.closePath = function () {
        this.currentPath_.push({ type: 'close' });
      };
      contextPrototype.getCoords_ = function (aX, aY) {
        var m = this.m_;
        return {
          x: aX * m[0][0] + aY * m[1][0] + m[2][0],
          y: aX * m[0][1] + aY * m[1][1] + m[2][1]
        };
      };
      contextPrototype.save = function () {
        var o = {};
        copyState(this, o);
        this.aStack_.push(o);
        this.mStack_.push(this.m_);
        this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
      };
      contextPrototype.restore = function () {
        copyState(this.aStack_.pop(), this);
        this.m_ = this.mStack_.pop();
      };
      function matrixIsFinite(m) {
        for (var j = 0; j < 3; j++) {
          for (var k = 0; k < 2; k++) {
            if (!isFinite(m[j][k]) || isNaN(m[j][k])) {
              return false;
            }
          }
        }
        return true;
      }
      function setM(ctx, m, updateLineScale) {
        if (!matrixIsFinite(m)) {
          return;
        }
        ctx.m_ = m;
        if (updateLineScale) {
          var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
          ctx.lineScale_ = sqrt(abs(det));
        }
      }
      contextPrototype.translate = function (aX, aY) {
        var m1 = [
            [
              1,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              aX,
              aY,
              1
            ]
          ];
        setM(this, matrixMultiply(m1, this.m_), false);
      };
      contextPrototype.rotate = function (aRot) {
        var c = mc(aRot);
        var s = ms(aRot);
        var m1 = [
            [
              c,
              s,
              0
            ],
            [
              -s,
              c,
              0
            ],
            [
              0,
              0,
              1
            ]
          ];
        setM(this, matrixMultiply(m1, this.m_), false);
      };
      contextPrototype.scale = function (aX, aY) {
        this.arcScaleX_ *= aX;
        this.arcScaleY_ *= aY;
        var m1 = [
            [
              aX,
              0,
              0
            ],
            [
              0,
              aY,
              0
            ],
            [
              0,
              0,
              1
            ]
          ];
        setM(this, matrixMultiply(m1, this.m_), true);
      };
      contextPrototype.transform = function (m11, m12, m21, m22, dx, dy) {
        var m1 = [
            [
              m11,
              m12,
              0
            ],
            [
              m21,
              m22,
              0
            ],
            [
              dx,
              dy,
              1
            ]
          ];
        setM(this, matrixMultiply(m1, this.m_), true);
      };
      contextPrototype.setTransform = function (m11, m12, m21, m22, dx, dy) {
        var m = [
            [
              m11,
              m12,
              0
            ],
            [
              m21,
              m22,
              0
            ],
            [
              dx,
              dy,
              1
            ]
          ];
        setM(this, m, true);
      };
      contextPrototype.clip = function () {
      };
      contextPrototype.arcTo = function () {
      };
      contextPrototype.createPattern = function () {
        return new CanvasPattern_;
      };
      function CanvasGradient_(aType) {
        this.type_ = aType;
        this.x0_ = 0;
        this.y0_ = 0;
        this.r0_ = 0;
        this.x1_ = 0;
        this.y1_ = 0;
        this.r1_ = 0;
        this.colors_ = [];
      }
      CanvasGradient_.prototype.addColorStop = function (aOffset, aColor) {
        aColor = processStyle(aColor);
        this.colors_.push({
          offset: aOffset,
          color: aColor.color,
          alpha: aColor.alpha
        });
      };
      function CanvasPattern_() {
      }
      module.exports = CanvasRenderingContext2D_;
    }());
  });
  require.define('/lib/pdffont.js', function (module, exports, __dirname, __filename) {
    var nodeUtil = require('/lib/util.js', module), _ = require('/node_modules/underscore/underscore.js', module), PDFUnit = require('/lib/pdfunit.js', module);
    var PDFFont = function PFPFontClosure() {
        'use strict';
        var _nextId = 1;
        var _name = 'PDFFont';
        var _boldSubNames = [
            'bd',
            'bold',
            'demi',
            'black'
          ];
        var _stdFonts = [
            'arial',
            'helvetica',
            'sans-serif ',
            'courier ',
            'monospace ',
            'ocr '
          ];
        var _kFontFaces = [
            'quicktype,arial,helvetica,sans-serif',
            'quicktype condensed,arial narrow,arial,helvetica,sans-serif',
            'quicktypepi,quicktypeiipi',
            'quicktype mono,courier new,courier,monospace',
            'ocr-a,courier new,courier,monospace',
            'ocr b mt,courier new,courier,monospace'
          ];
        var _kFontStyles = [
            [
              0,
              6,
              0,
              0
            ],
            [
              0,
              8,
              0,
              0
            ],
            [
              0,
              10,
              0,
              0
            ],
            [
              0,
              12,
              0,
              0
            ],
            [
              0,
              14,
              0,
              0
            ],
            [
              0,
              18,
              0,
              0
            ],
            [
              0,
              6,
              1,
              0
            ],
            [
              0,
              8,
              1,
              0
            ],
            [
              0,
              10,
              1,
              0
            ],
            [
              0,
              12,
              1,
              0
            ],
            [
              0,
              14,
              1,
              0
            ],
            [
              0,
              18,
              1,
              0
            ],
            [
              0,
              6,
              0,
              1
            ],
            [
              0,
              8,
              0,
              1
            ],
            [
              0,
              10,
              0,
              1
            ],
            [
              0,
              12,
              0,
              1
            ],
            [
              0,
              14,
              0,
              1
            ],
            [
              0,
              18,
              0,
              1
            ],
            [
              0,
              6,
              1,
              1
            ],
            [
              0,
              8,
              1,
              1
            ],
            [
              0,
              10,
              1,
              1
            ],
            [
              0,
              12,
              1,
              1
            ],
            [
              0,
              14,
              1,
              1
            ],
            [
              0,
              18,
              1,
              1
            ],
            [
              1,
              6,
              0,
              0
            ],
            [
              1,
              8,
              0,
              0
            ],
            [
              1,
              10,
              0,
              0
            ],
            [
              1,
              12,
              0,
              0
            ],
            [
              1,
              14,
              0,
              0
            ],
            [
              1,
              18,
              0,
              0
            ],
            [
              1,
              6,
              1,
              0
            ],
            [
              1,
              8,
              1,
              0
            ],
            [
              1,
              10,
              1,
              0
            ],
            [
              1,
              12,
              1,
              0
            ],
            [
              1,
              14,
              1,
              0
            ],
            [
              1,
              18,
              1,
              0
            ],
            [
              1,
              6,
              0,
              1
            ],
            [
              1,
              8,
              0,
              1
            ],
            [
              1,
              10,
              0,
              1
            ],
            [
              1,
              12,
              0,
              1
            ],
            [
              1,
              14,
              0,
              1
            ],
            [
              1,
              18,
              0,
              1
            ],
            [
              2,
              8,
              0,
              0
            ],
            [
              2,
              10,
              0,
              0
            ],
            [
              2,
              12,
              0,
              0
            ],
            [
              2,
              14,
              0,
              0
            ],
            [
              2,
              18,
              0,
              0
            ],
            [
              3,
              8,
              0,
              0
            ],
            [
              3,
              10,
              0,
              0
            ],
            [
              3,
              12,
              0,
              0
            ],
            [
              4,
              12,
              0,
              0
            ],
            [
              0,
              9,
              0,
              0
            ],
            [
              0,
              9,
              1,
              0
            ],
            [
              0,
              9,
              0,
              1
            ],
            [
              0,
              9,
              1,
              1
            ],
            [
              1,
              9,
              0,
              0
            ],
            [
              1,
              9,
              1,
              0
            ],
            [
              1,
              9,
              1,
              1
            ],
            [
              4,
              10,
              0,
              0
            ],
            [
              5,
              10,
              0,
              0
            ],
            [
              5,
              12,
              0,
              0
            ]
          ];
        var cls = function (fontObj) {
          var _id = _nextId++;
          this.get_id = function () {
            return _id;
          };
          this.get_name = function () {
            return _name + _id;
          };
          this.fontObj = fontObj;
          var typeName = fontObj.name || fontObj.fallbackName;
          if (!typeName) {
            typeName = _kFontFaces[0];
          }
          typeName = typeName.toLowerCase();
          this.typeName = typeName;
          var subType = typeName;
          var nameArray = typeName.split('+');
          if (_.isArray(nameArray) && nameArray.length > 1) {
            subType = nameArray[1].split('-');
            if (_.isArray(subType) && subType.length > 1) {
              if (!this.bold) {
                var subName = subType[1].toLowerCase();
                this.bold = _boldSubNames.indexOf(subName) >= 0;
              }
              subType = subType[0];
            }
          }
          this.subType = subType;
          this.isSymbol = typeName.indexOf('symbol') > 0 || _kFontFaces[2].indexOf(this.subType) >= 0;
          if (this.fontObj.isSymbolicFont) {
            var mFonts = _.filter(_stdFonts, function (oneName) {
                return typeName.indexOf(oneName) >= 0;
              }, this);
            if (mFonts.length > 0) {
              this.fontObj.isSymbolicFont = false;
              nodeUtil.p2jinfo('Reset: isSymbolicFont (false) for ' + this.fontObj.name);
            }
          } else {
            if (this.isSymbol) {
              this.fontObj.isSymbolicFont = true;
              nodeUtil.p2jinfo('Reset: isSymbolicFont (true) for ' + this.fontObj.name);
            }
          }
          this.fontSize = 1;
          this.faceIdx = 0;
          this.bold = false;
          this.italic = false;
          this.fontStyleId = -1;
        };
        cls.get_nextId = function () {
          return _name + _nextId;
        };
        var _setFaceIndex = function () {
          var fontObj = this.fontObj;
          this.bold = fontObj.bold;
          if (!this.bold) {
            this.bold = this.typeName.indexOf('bold') >= 0 || this.typeName.indexOf('black') >= 0;
          }
          var typeName = this.subType;
          if (fontObj.isSerifFont) {
            if (_kFontFaces[1].indexOf(typeName) >= 0)
              this.faceIdx = 1;
          } else if (_kFontFaces[2].indexOf(this.subType) >= 0) {
            this.faceIdx = 2;
          } else if (fontObj.isMonospace) {
            this.faceIdx = 3;
            if (_kFontFaces[4].indexOf(typeName) >= 0)
              this.faceIdx = 4;
            else if (_kFontFaces[5].indexOf(typeName) >= 0)
              this.faceIdx = 5;
          } else if (fontObj.isSymbolicFont) {
            this.faceIdx = 2;
          }
          if (this.faceIdx == 0) {
            if (this.typeName.indexOf('narrow') > 0)
              this.faceIdx = 1;
          }
        };
        var _getFontStyleIndex = function (fontSize) {
          _setFaceIndex.call(this);
          this.fontSize = this.bold && fontSize > 12 ? fontSize + 1 : fontSize;
          var fsa = [
              this.faceIdx,
              this.fontSize,
              this.bold ? 1 : 0,
              this.italic ? 1 : 0
            ];
          var retVal = -1;
          _.each(_kFontStyles, function (element, index, list) {
            if (retVal === -1) {
              if (element[0] === fsa[0] && element[1] === fsa[1] && element[2] === fsa[2] && element[3] === fsa[3]) {
                retVal = index;
              }
            }
          });
          return retVal;
        };
        var _processSymbolicFont = function (str) {
          var retVal = str;
          if (!str || str.length !== 1)
            return retVal;
          if (!this.fontObj.isSymbolicFont || !this.isSymbol) {
            if (retVal == 'C' || retVal == 'G') {
              retVal = ' ' + retVal + ' ';
            }
            return retVal;
          }
          switch (str.charCodeAt(0)) {
          case 20:
            retVal = '\u2713';
            break;
          case 70:
            retVal = this.fontObj.type === 'CIDFontType0' ? '\u26A0' : '}';
            break;
          case 71:
            retVal = '\u25B6';
            break;
          case 97:
            retVal = '\u25B6';
            break;
          case 99:
            retVal = this.isSymbol ? '\u2022' : '\u25B2';
            break;
          case 100:
            retVal = '\u25BC';
            break;
          case 103:
            retVal = '\u27A8';
            break;
          case 106:
            retVal = '';
            break;
          case 114:
            retVal = '\u2022';
            break;
          case 115:
            retVal = '\u25B2';
            break;
          case 116:
            retVal = '\u2022';
            break;
          case 118:
            retVal = '\u2022';
            break;
          default:
            nodeUtil.p2jinfo(this.fontObj.type + ' - SymbolicFont - (' + this.fontObj.name + ') : ' + str.charCodeAt(0) + '::' + str.charCodeAt(1) + ' => ' + retVal);
          }
          return retVal;
        };
        var _textRotationAngle = function (matrix2D) {
          var retVal = 0;
          if (matrix2D[0][0] === 0 && matrix2D[1][1] === 0) {
            if (matrix2D[0][1] != 0 && matrix2D[1][0] != 0) {
              if (matrix2D[0][1] / matrix2D[1][0] + 1 < 1e-4)
                retVal = 90;
            }
          } else if (matrix2D[0][0] !== 0 && matrix2D[1][1] !== 0) {
            var r1 = Math.atan(-matrix2D[0][1] / matrix2D[0][0]);
            var r2 = Math.atan(matrix2D[1][0] / matrix2D[1][1]);
            if (Math.abs(r1) > 1e-4 && r1 - r2 < 1e-4) {
              retVal = r1 * 180 / Math.PI;
            }
          }
          return retVal;
        };
        cls.prototype.processText = function (p, str, maxWidth, color, fontSize, targetData, matrix2D) {
          var text = _processSymbolicFont.call(this, str);
          if (!text) {
            return;
          }
          this.fontStyleId = _getFontStyleIndex.call(this, fontSize);
          var TS = [
              this.faceIdx,
              this.fontSize,
              this.bold ? 1 : 0,
              this.italic ? 1 : 0
            ];
          var clrId = PDFUnit.findColorIndex(color);
          var oneText = {
              x: PDFUnit.toFormX(p.x) - .25,
              y: PDFUnit.toFormY(p.y) - .75,
              w: maxWidth,
              clr: clrId,
              A: 'left',
              R: [{
                  T: this.flash_encode(text),
                  S: this.fontStyleId,
                  TS: TS
                }]
            };
          if (clrId < 0) {
            oneText = _.extend({ oc: color }, oneText);
          }
          var rAngle = _textRotationAngle.call(this, matrix2D);
          if (rAngle != 0) {
            nodeUtil.p2jinfo(str + ': rotated ' + rAngle + ' degree.');
            _.extend(oneText.R[0], { RA: rAngle });
          }
          targetData.Texts.push(oneText);
        };
        cls.prototype.flash_encode = function (str) {
          var retVal = encodeURIComponent(str);
          retVal = retVal.replace('%C2%96', '-');
          retVal = retVal.replace('%C2%91', '%27');
          retVal = retVal.replace('%C2%92', '%27');
          retVal = retVal.replace('%C2%82', '%27');
          retVal = retVal.replace('%C2%93', '%22');
          retVal = retVal.replace('%C2%94', '%22');
          retVal = retVal.replace('%C2%84', '%22');
          retVal = retVal.replace('%C2%8B', '%C2%AB');
          retVal = retVal.replace('%C2%9B', '%C2%BB');
          return retVal;
        };
        cls.prototype.clean = function () {
          this.fontObj = null;
          delete this.fontObj;
        };
        return cls;
      }();
    module.exports = PDFFont;
  });
  require.define('/lib/pdffill.js', function (module, exports, __dirname, __filename) {
    var nodeUtil = require('/lib/util.js', module), _ = require('/node_modules/underscore/underscore.js', module), PDFUnit = require('/lib/pdfunit.js', module);
    var PDFFill = function PFPLineClosure() {
        'use strict';
        var _nextId = 1;
        var _name = 'PDFFill';
        var cls = function (x, y, width, height, color) {
          var _id = _nextId++;
          this.get_id = function () {
            return _id;
          };
          this.get_name = function () {
            return _name + _id;
          };
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.color = color;
        };
        cls.get_nextId = function () {
          return _name + _nextId;
        };
        cls.prototype.processFill = function (targetData) {
          var clrId = PDFUnit.findColorIndex(this.color);
          var oneFill = {
              x: PDFUnit.toFormX(this.x),
              y: PDFUnit.toFormY(this.y),
              w: PDFUnit.toFormX(this.width),
              h: PDFUnit.toFormY(this.height),
              clr: clrId
            };
          if (clrId < 0) {
            oneFill = _.extend({ oc: this.color }, oneFill);
          }
          targetData.Fills.push(oneFill);
        };
        return cls;
      }();
    module.exports = PDFFill;
  });
  require.define('/lib/pdfline.js', function (module, exports, __dirname, __filename) {
    var nodeUtil = require('/lib/util.js', module), _ = require('/node_modules/underscore/underscore.js', module), PDFUnit = require('/lib/pdfunit.js', module);
    var PDFLine = function PFPLineClosure() {
        'use strict';
        var _nextId = 1;
        var _name = 'PDFLine';
        var cls = function (x1, y1, x2, y2, lineWidth, color, dashed) {
          var _id = _nextId++;
          this.get_id = function () {
            return _id;
          };
          this.get_name = function () {
            return _name + _id;
          };
          this.x1 = x1;
          this.y1 = y1;
          this.x2 = x2;
          this.y2 = y2;
          this.lineWidth = lineWidth || 1;
          this.color = color;
          this.dashed = dashed;
        };
        cls.get_nextId = function () {
          return _name + _nextId;
        };
        var _setStartPoint = function (oneLine, x, y) {
          oneLine.x = PDFUnit.toFormX(x);
          oneLine.y = PDFUnit.toFormY(y);
        };
        cls.prototype.processLine = function (targetData) {
          var xDelta = Math.abs(this.x2 - this.x1);
          var yDelta = Math.abs(this.y2 - this.y1);
          var minDelta = this.lineWidth;
          var oneLine = {
              x: 0,
              y: 0,
              w: this.lineWidth,
              l: 0
            };
          var clrId = PDFUnit.findColorIndex(this.color);
          if (clrId < 0) {
            oneLine = _.extend({ oc: this.color }, oneLine);
          } else if (clrId > 0 && clrId < PDFUnit.colorCount() - 1) {
            oneLine = _.extend({ clr: clrId }, oneLine);
          }
          if (this.dashed) {
            oneLine = _.extend({ dsh: 1 }, oneLine);
          }
          if (yDelta < this.lineWidth && xDelta > minDelta) {
            if (this.lineWidth < 4 && xDelta / this.lineWidth < 4) {
              nodeUtil.p2jinfo('Skipped: short thick HLine: lineWidth = ' + this.lineWidth + ', xDelta = ' + xDelta);
              return;
            }
            oneLine.l = PDFUnit.toFormX(xDelta);
            if (this.x1 > this.x2)
              _setStartPoint.call(this, oneLine, this.x2, this.y2);
            else
              _setStartPoint.call(this, oneLine, this.x1, this.y1);
            targetData.HLines.push(oneLine);
          } else if (xDelta < this.lineWidth && yDelta > minDelta) {
            if (this.lineWidth < 4 && yDelta / this.lineWidth < 4) {
              nodeUtil.p2jinfo('Skipped: short thick VLine: lineWidth = ' + this.lineWidth + ', yDelta = ' + yDelta);
              return;
            }
            oneLine.l = PDFUnit.toFormY(yDelta);
            if (this.y1 > this.y2)
              _setStartPoint.call(this, oneLine, this.x2, this.y2);
            else
              _setStartPoint.call(this, oneLine, this.x1, this.y1);
            targetData.VLines.push(oneLine);
          }
        };
        return cls;
      }();
    module.exports = PDFLine;
  });
  require.define('/pdfparser.js', function (module, exports, __dirname, __filename) {
    var PDFJS = require('/lib/pdf.js', module), nodeUtil = require('/lib/util.js', module), nodeEvents = require('events', module), _ = require('/node_modules/underscore/underscore.js', module), async = require('/node_modules/async/lib/async.js', module);
    var PDFParser = function () {
        'use strict';
        var _nextId = 1;
        var _name = 'PDFParser';
        var _binBuffer = {};
        var _maxBinBufferCount = 10;
        var cls = function (context, needRawText) {
          nodeEvents.EventEmitter.call(this);
          var _id = _nextId++;
          this.get_id = function () {
            return _id;
          };
          this.get_name = function () {
            return _name + _id;
          };
          this.context = context;
          this.pdfFilePath = null;
          this.data = null;
          this.PDFJS = new PDFJS(needRawText);
          this.parsePropCount = 0;
          this.processFieldInfoXML = false;
        };
        nodeUtil.inherits(cls, nodeEvents.EventEmitter);
        cls.get_nextId = function () {
          return _name + _nextId;
        };
        var _onPDFJSParseDataReady = function (data) {
          _.extend(this.data, data);
          this.parsePropCount++;
          if (this.parsePropCount >= 2) {
            this.emit('pdfParser_dataReady', this);
            nodeUtil.p2jinfo('PDF parsing completed.');
          }
        };
        var _onPDFJSParserDataError = function (data) {
          this.data = data;
          this.emit('pdfParser_dataError', this);
        };
        var startParsingPDF = function (buffer) {
          this.data = {};
          this.parsePropCount = 0;
          this.PDFJS.on('pdfjs_parseDataReady', _.bind(_onPDFJSParseDataReady, this));
          this.PDFJS.on('pdfjs_parseDataError', _.bind(_onPDFJSParserDataError, this));
          this.PDFJS.parsePDFData((buffer && buffer.uint8array) || buffer || _binBuffer[this.pdfFilePath]);
        };
        var processBinaryCache = function () {
          if (_.has(_binBuffer, this.pdfFilePath)) {
            startParsingPDF.call(this);
            return true;
          }
          var allKeys = _.keys(_binBuffer);
          if (allKeys.length > _maxBinBufferCount) {
            var idx = this.get_id() % _maxBinBufferCount;
            var key = allKeys[idx];
            _binBuffer[key] = null;
            delete _binBuffer[key];
            nodeUtil.p2jinfo('re-cycled cache for ' + key);
          }
          return false;
        };
        var processPDFContent = function (err, data) {
          nodeUtil.p2jinfo('Load PDF file status:' + (!!err ? 'Error!' : 'Success!'));
          if (err) {
            this.data = err;
            this.emit('pdfParser_dataError', this);
          } else {
            _binBuffer[this.pdfFilePath] = data;
            startParsingPDF.call(this);
          }
        };
        cls.prototype.parseBuffer = function (pdfBuffer) {
          startParsingPDF.call(this, pdfBuffer);
        };
        cls.prototype.getRawTextContent = function () {
          return this.PDFJS.getRawTextContent();
        };
        cls.prototype.destroy = function () {
          this.removeAllListeners();
          if (this.context) {
            this.context.destroy();
            this.context = null;
          }
          this.pdfFilePath = null;
          this.data = null;
          this.PDFJS.destroy();
          this.PDFJS = null;
          this.parsePropCount = 0;
        };
        return cls;
      }();
    module.exports = PDFParser;
  });
  require.define('/node_modules/async/lib/async.js', function (module, exports, __dirname, __filename) {
    (function () {
      var async = {};
      var root, previous_async;
      root = this;
      if (root != null) {
        previous_async = root.async;
      }
      async.noConflict = function () {
        root.async = previous_async;
        return async;
      };
      function only_once(fn) {
        var called = false;
        return function () {
          if (called)
            throw new Error('Callback was already called.');
          called = true;
          fn.apply(root, arguments);
        };
      }
      var _each = function (arr, iterator) {
        if (arr.forEach) {
          return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
          iterator(arr[i], i, arr);
        }
      };
      var _map = function (arr, iterator) {
        if (arr.map) {
          return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
          results.push(iterator(x, i, a));
        });
        return results;
      };
      var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
          return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
          memo = iterator(memo, x, i, a);
        });
        return memo;
      };
      var _keys = function (obj) {
        if (Object.keys) {
          return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
          if (obj.hasOwnProperty(k)) {
            keys.push(k);
          }
        }
        return keys;
      };
      if (typeof process === 'undefined' || !process.nextTick) {
        if (typeof setImmediate === 'function') {
          async.nextTick = function (fn) {
            setImmediate(fn);
          };
        } else {
          async.nextTick = function (fn) {
            setABTimeout(fn, 0);
          };
        }
      } else {
        async.nextTick = process.nextTick;
      }
      async.each = function (arr, iterator, callback) {
        callback = callback || function () {
        };
        if (!arr.length) {
          return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
          iterator(x, only_once(function (err) {
            if (err) {
              callback(err);
              callback = function () {
              };
            } else {
              completed += 1;
              if (completed >= arr.length) {
                callback(null);
              }
            }
          }));
        });
      };
      async.forEach = async.each;
      async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {
        };
        if (!arr.length) {
          return callback();
        }
        var completed = 0;
        var iterate = function () {
          var sync = true;
          iterator(arr[completed], function (err) {
            if (err) {
              callback(err);
              callback = function () {
              };
            } else {
              completed += 1;
              if (completed >= arr.length) {
                callback(null);
              } else {
                if (sync) {
                  async.nextTick(iterate);
                } else {
                  iterate();
                }
              }
            }
          });
          sync = false;
        };
        iterate();
      };
      async.forEachSeries = async.eachSeries;
      async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [
          arr,
          iterator,
          callback
        ]);
      };
      async.forEachLimit = async.eachLimit;
      var _eachLimit = function (limit) {
        return function (arr, iterator, callback) {
          callback = callback || function () {
          };
          if (!arr.length || limit <= 0) {
            return callback();
          }
          var completed = 0;
          var started = 0;
          var running = 0;
          (function replenish() {
            if (completed >= arr.length) {
              return callback();
            }
            while (running < limit && started < arr.length) {
              started += 1;
              running += 1;
              iterator(arr[started - 1], function (err) {
                if (err) {
                  callback(err);
                  callback = function () {
                  };
                } else {
                  completed += 1;
                  running -= 1;
                  if (completed >= arr.length) {
                    callback();
                  } else {
                    replenish();
                  }
                }
              });
            }
          }());
        };
      };
      var doParallel = function (fn) {
        return function () {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [async.each].concat(args));
        };
      };
      var doParallelLimit = function (limit, fn) {
        return function () {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
      };
      var doSeries = function (fn) {
        return function () {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [async.eachSeries].concat(args));
        };
      };
      var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
          return {
            index: i,
            value: x
          };
        });
        eachfn(arr, function (x, callback) {
          iterator(x.value, function (err, v) {
            results[x.index] = v;
            callback(err);
          });
        }, function (err) {
          callback(err, results);
        });
      };
      async.map = doParallel(_asyncMap);
      async.mapSeries = doSeries(_asyncMap);
      async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
      };
      var _mapLimit = function (limit) {
        return doParallelLimit(limit, _asyncMap);
      };
      async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
          iterator(memo, x, function (err, v) {
            memo = v;
            callback(err);
          });
        }, function (err) {
          callback(err, memo);
        });
      };
      async.inject = async.reduce;
      async.foldl = async.reduce;
      async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
          }).reverse();
        async.reduce(reversed, memo, iterator, callback);
      };
      async.foldr = async.reduceRight;
      var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
          return {
            index: i,
            value: x
          };
        });
        eachfn(arr, function (x, callback) {
          iterator(x.value, function (v) {
            if (v) {
              results.push(x);
            }
            callback();
          });
        }, function (err) {
          callback(_map(results.sort(function (a, b) {
            return a.index - b.index;
          }), function (x) {
            return x.value;
          }));
        });
      };
      async.filter = doParallel(_filter);
      async.filterSeries = doSeries(_filter);
      async.select = async.filter;
      async.selectSeries = async.filterSeries;
      var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
          return {
            index: i,
            value: x
          };
        });
        eachfn(arr, function (x, callback) {
          iterator(x.value, function (v) {
            if (!v) {
              results.push(x);
            }
            callback();
          });
        }, function (err) {
          callback(_map(results.sort(function (a, b) {
            return a.index - b.index;
          }), function (x) {
            return x.value;
          }));
        });
      };
      async.reject = doParallel(_reject);
      async.rejectSeries = doSeries(_reject);
      var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
          iterator(x, function (result) {
            if (result) {
              main_callback(x);
              main_callback = function () {
              };
            } else {
              callback();
            }
          });
        }, function (err) {
          main_callback();
        });
      };
      async.detect = doParallel(_detect);
      async.detectSeries = doSeries(_detect);
      async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
          iterator(x, function (v) {
            if (v) {
              main_callback(true);
              main_callback = function () {
              };
            }
            callback();
          });
        }, function (err) {
          main_callback(false);
        });
      };
      async.any = async.some;
      async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
          iterator(x, function (v) {
            if (!v) {
              main_callback(false);
              main_callback = function () {
              };
            }
            callback();
          });
        }, function (err) {
          main_callback(true);
        });
      };
      async.all = async.every;
      async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
          iterator(x, function (err, criteria) {
            if (err) {
              callback(err);
            } else {
              callback(null, {
                value: x,
                criteria: criteria
              });
            }
          });
        }, function (err, results) {
          if (err) {
            return callback(err);
          } else {
            var fn = function (left, right) {
              var a = left.criteria, b = right.criteria;
              return a < b ? -1 : a > b ? 1 : 0;
            };
            callback(null, _map(results.sort(fn), function (x) {
              return x.value;
            }));
          }
        });
      };
      async.auto = function (tasks, callback) {
        callback = callback || function () {
        };
        var keys = _keys(tasks);
        if (!keys.length) {
          return callback(null);
        }
        var results = {};
        var listeners = [];
        var addListener = function (fn) {
          listeners.unshift(fn);
        };
        var removeListener = function (fn) {
          for (var i = 0; i < listeners.length; i += 1) {
            if (listeners[i] === fn) {
              listeners.splice(i, 1);
              return;
            }
          }
        };
        var taskComplete = function () {
          _each(listeners.slice(0), function (fn) {
            fn();
          });
        };
        addListener(function () {
          if (_keys(results).length === keys.length) {
            callback(null, results);
            callback = function () {
            };
          }
        });
        _each(keys, function (k) {
          var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];
          var taskCallback = function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            if (err) {
              var safeResults = {};
              _each(_keys(results), function (rkey) {
                safeResults[rkey] = results[rkey];
              });
              safeResults[k] = args;
              callback(err, safeResults);
              callback = function () {
              };
            } else {
              results[k] = args;
              async.nextTick(taskComplete);
            }
          };
          var requires = task.slice(0, Math.abs(task.length - 1)) || [];
          var ready = function () {
            return _reduce(requires, function (a, x) {
              return a && results.hasOwnProperty(x);
            }, true) && !results.hasOwnProperty(k);
          };
          if (ready()) {
            task[task.length - 1](taskCallback, results);
          } else {
            var listener = function () {
              if (ready()) {
                removeListener(listener);
                task[task.length - 1](taskCallback, results);
              }
            };
            addListener(listener);
          }
        });
      };
      async.waterfall = function (tasks, callback) {
        callback = callback || function () {
        };
        if (!tasks.length) {
          return callback();
        }
        var wrapIterator = function (iterator) {
          return function (err) {
            if (err) {
              callback.apply(null, arguments);
              callback = function () {
              };
            } else {
              var args = Array.prototype.slice.call(arguments, 1);
              var next = iterator.next();
              if (next) {
                args.push(wrapIterator(next));
              } else {
                args.push(callback);
              }
              async.nextTick(function () {
                iterator.apply(null, args);
              });
            }
          };
        };
        wrapIterator(async.iterator(tasks))();
      };
      var _parallel = function (eachfn, tasks, callback) {
        callback = callback || function () {
        };
        if (tasks.constructor === Array) {
          eachfn.map(tasks, function (fn, callback) {
            if (fn) {
              fn(function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                callback.call(null, err, args);
              });
            }
          }, callback);
        } else {
          var results = {};
          eachfn.each(_keys(tasks), function (k, callback) {
            tasks[k](function (err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (args.length <= 1) {
                args = args[0];
              }
              results[k] = args;
              callback(err);
            });
          }, function (err) {
            callback(err, results);
          });
        }
      };
      async.parallel = function (tasks, callback) {
        _parallel({
          map: async.map,
          each: async.each
        }, tasks, callback);
      };
      async.parallelLimit = function (tasks, limit, callback) {
        _parallel({
          map: _mapLimit(limit),
          each: _eachLimit(limit)
        }, tasks, callback);
      };
      async.series = function (tasks, callback) {
        callback = callback || function () {
        };
        if (tasks.constructor === Array) {
          async.mapSeries(tasks, function (fn, callback) {
            if (fn) {
              fn(function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                callback.call(null, err, args);
              });
            }
          }, callback);
        } else {
          var results = {};
          async.eachSeries(_keys(tasks), function (k, callback) {
            tasks[k](function (err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (args.length <= 1) {
                args = args[0];
              }
              results[k] = args;
              callback(err);
            });
          }, function (err) {
            callback(err, results);
          });
        }
      };
      async.iterator = function (tasks) {
        var makeCallback = function (index) {
          var fn = function () {
            if (tasks.length) {
              tasks[index].apply(null, arguments);
            }
            return fn.next();
          };
          fn.next = function () {
            return index < tasks.length - 1 ? makeCallback(index + 1) : null;
          };
          return fn;
        };
        return makeCallback(0);
      };
      async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
          return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));
        };
      };
      var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
          fn(x, function (err, y) {
            r = r.concat(y || []);
            cb(err);
          });
        }, function (err) {
          callback(err, r);
        });
      };
      async.concat = doParallel(_concat);
      async.concatSeries = doSeries(_concat);
      async.whilst = function (test, iterator, callback) {
        if (test()) {
          var sync = true;
          iterator(function (err) {
            if (err) {
              return callback(err);
            }
            if (sync) {
              async.nextTick(function () {
                async.whilst(test, iterator, callback);
              });
            } else {
              async.whilst(test, iterator, callback);
            }
          });
          sync = false;
        } else {
          callback();
        }
      };
      async.doWhilst = function (iterator, test, callback) {
        var sync = true;
        iterator(function (err) {
          if (err) {
            return callback(err);
          }
          if (test()) {
            if (sync) {
              async.nextTick(function () {
                async.doWhilst(iterator, test, callback);
              });
            } else {
              async.doWhilst(iterator, test, callback);
            }
          } else {
            callback();
          }
        });
        sync = false;
      };
      async.until = function (test, iterator, callback) {
        if (!test()) {
          var sync = true;
          iterator(function (err) {
            if (err) {
              return callback(err);
            }
            if (sync) {
              async.nextTick(function () {
                async.until(test, iterator, callback);
              });
            } else {
              async.until(test, iterator, callback);
            }
          });
          sync = false;
        } else {
          callback();
        }
      };
      async.doUntil = function (iterator, test, callback) {
        var sync = true;
        iterator(function (err) {
          if (err) {
            return callback(err);
          }
          if (!test()) {
            if (sync) {
              async.nextTick(function () {
                async.doUntil(iterator, test, callback);
              });
            } else {
              async.doUntil(iterator, test, callback);
            }
          } else {
            callback();
          }
        });
        sync = false;
      };
      async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
          concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (data.constructor !== Array) {
            data = [data];
          }
          _each(data, function (task) {
            var item = {
                data: task,
                callback: typeof callback === 'function' ? callback : null
              };
            if (pos) {
              q.tasks.unshift(item);
            } else {
              q.tasks.push(item);
            }
            if (q.saturated && q.tasks.length === concurrency) {
              q.saturated();
            }
            async.nextTick(q.process);
          });
        }
        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
              if (workers < q.concurrency && q.tasks.length) {
                var task = q.tasks.shift();
                if (q.empty && q.tasks.length === 0) {
                  q.empty();
                }
                workers += 1;
                var sync = true;
                var next = function () {
                  workers -= 1;
                  if (task.callback) {
                    task.callback.apply(task, arguments);
                  }
                  if (q.drain && q.tasks.length + workers === 0) {
                    q.drain();
                  }
                  q.process();
                };
                var cb = only_once(function () {
                    var cbArgs = arguments;
                    if (sync) {
                      async.nextTick(function () {
                        next.apply(null, cbArgs);
                      });
                    } else {
                      next.apply(null, arguments);
                    }
                  });
                worker(task.data, cb);
                sync = false;
              }
            },
            length: function () {
              return q.tasks.length;
            },
            running: function () {
              return workers;
            }
          };
        return q;
      };
      async.cargo = function (worker, payload) {
        var working = false, tasks = [];
        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              if (data.constructor !== Array) {
                data = [data];
              }
              _each(data, function (task) {
                tasks.push({
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
                });
                if (cargo.saturated && tasks.length === payload) {
                  cargo.saturated();
                }
              });
              async.nextTick(cargo.process);
            },
            process: function process() {
              if (working)
                return;
              if (tasks.length === 0) {
                if (cargo.drain)
                  cargo.drain();
                return;
              }
              var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0);
              var ds = _map(ts, function (task) {
                  return task.data;
                });
              if (cargo.empty)
                cargo.empty();
              working = true;
              worker(ds, function () {
                working = false;
                var args = arguments;
                _each(ts, function (data) {
                  if (data.callback) {
                    data.callback.apply(null, args);
                  }
                });
                process();
              });
            },
            length: function () {
              return tasks.length;
            },
            running: function () {
              return working;
            }
          };
        return cargo;
      };
      var _console_fn = function (name) {
        return function (fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          fn.apply(null, args.concat([function (err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (typeof console !== 'undefined') {
                if (err) {
                  if (console.error) {
                    console.error(err);
                  }
                } else if (console[name]) {
                  _each(args, function (x) {
                    console[name](x);
                  });
                }
              }
            }]));
        };
      };
      async.log = _console_fn('log');
      async.dir = _console_fn('dir');
      async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
          return x;
        };
        var memoized = function () {
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          var key = hasher.apply(null, args);
          if (key in memo) {
            callback.apply(null, memo[key]);
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            fn.apply(null, args.concat([function () {
                memo[key] = arguments;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                  q[i].apply(null, arguments);
                }
              }]));
          }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      };
      async.unmemoize = function (fn) {
        return function () {
          return (fn.unmemoized || fn).apply(null, arguments);
        };
      };
      async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
          counter.push(i);
        }
        return async.map(counter, iterator, callback);
      };
      async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
          counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
      };
      async.compose = function () {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
          var that = this;
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          async.reduce(fns, args, function (newargs, fn, cb) {
            fn.apply(that, newargs.concat([function () {
                var err = arguments[0];
                var nextargs = Array.prototype.slice.call(arguments, 1);
                cb(err, nextargs);
              }]));
          }, function (err, results) {
            callback.apply(that, [err].concat(results));
          });
        };
      };
      async.applyEach = function (fns) {
        var go = function () {
          var that = this;
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          return async.each(fns, function (fn, cb) {
            fn.apply(that, args.concat([cb]));
          }, callback);
        };
        if (arguments.length > 1) {
          var args = Array.prototype.slice.call(arguments, 1);
          return go.apply(this, args);
        } else {
          return go;
        }
      };
      if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
          return async;
        });
      } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
      } else {
        root.async = async;
      }
    }());
  });
  require.define('events', function (module, exports, __dirname, __filename) {
    if (!process.EventEmitter)
      process.EventEmitter = function () {
      };
    var EventEmitter = exports.EventEmitter = process.EventEmitter;
    var isArray = typeof Array.isArray === 'function' ? Array.isArray : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };
    var defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function (n) {
      if (!this._events)
        this._events = {};
      this._events.maxListeners = n;
    };
    EventEmitter.prototype.emit = function (type) {
      if (type === 'error') {
        if (!this._events || !this._events.error || isArray(this._events.error) && !this._events.error.length) {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
          return false;
        }
      }
      if (!this._events)
        return false;
      var handler = this._events[type];
      if (!handler)
        return false;
      if (typeof handler == 'function') {
        switch (arguments.length) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          var args = Array.prototype.slice.call(arguments, 1);
          handler.apply(this, args);
        }
        return true;
      } else if (isArray(handler)) {
        var args = Array.prototype.slice.call(arguments, 1);
        var listeners = handler.slice();
        for (var i = 0, l = listeners.length; i < l; i++) {
          listeners[i].apply(this, args);
        }
        return true;
      } else {
        return false;
      }
    };
    EventEmitter.prototype.addListener = function (type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('addListener only takes instances of Function');
      }
      if (!this._events)
        this._events = {};
      this.emit('newListener', type, listener);
      if (!this._events[type]) {
        this._events[type] = listener;
      } else if (isArray(this._events[type])) {
        if (!this._events[type].warned) {
          var m;
          if (this._events.maxListeners !== undefined) {
            m = this._events.maxListeners;
          } else {
            m = defaultMaxListeners;
          }
          if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
            console.trace();
          }
        }
        this._events[type].push(listener);
      } else {
        this._events[type] = [
          this._events[type],
          listener
        ];
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function (type, listener) {
      var self = this;
      self.on(type, function g() {
        self.removeListener(type, g);
        listener.apply(this, arguments);
      });
      return this;
    };
    EventEmitter.prototype.removeListener = function (type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('removeListener only takes instances of Function');
      }
      if (!this._events || !this._events[type])
        return this;
      var list = this._events[type];
      if (isArray(list)) {
        var i = list.indexOf(listener);
        if (i < 0)
          return this;
        list.splice(i, 1);
        if (list.length == 0)
          delete this._events[type];
      } else if (this._events[type] === listener) {
        delete this._events[type];
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function (type) {
      if (type && this._events && this._events[type])
        this._events[type] = null;
      return this;
    };
    EventEmitter.prototype.listeners = function (type) {
      if (!this._events)
        this._events = {};
      if (!this._events[type])
        this._events[type] = [];
      if (!isArray(this._events[type])) {
        this._events[type] = [this._events[type]];
      }
      return this._events[type];
    };
  });
  require.define('/lib/pdf.js', function (module, exports, __dirname, __filename) {
    var nodeUtil = require('/lib/util.js', module), nodeEvents = require('events', module), _ = require('/node_modules/underscore/underscore.js', module), PDFCanvas = require('/lib/pdfcanvas.js', module), PDFUnit = require('/lib/pdfunit.js', module), PDFField = require('/lib/pdffield.js', module), PDFAnno = require('/lib/pdfanno.js', module), Image = require('/lib/pdfimage.js', module), pkInfo = require('/package.json', module);
    var _pdfjsFiles = [
        'shared/util.js',
        'shared/colorspace.js',
        'shared/pattern.js',
        'shared/function.js',
        'shared/annotation.js',
        'core/core.js',
        'core/obj.js',
        'core/charsets.js',
        'core/crypto.js',
        'core/evaluator.js',
        'core/fonts.js',
        'core/font_renderer.js',
        'core/glyphlist.js',
        'core/image.js',
        'core/metrics.js',
        'core/parser.js',
        'core/stream.js',
        'core/worker.js',
        'core/jpx.js',
        'core/jbig2.js',
        'core/bidi.js',
        'core/jpg.js',
        'core/chunked_stream.js',
        'core/pdf_manager.js',
        'core/cmap.js',
        'core/cidmaps.js',
        'display/canvas.js',
        'display/font_loader.js',
        'display/metadata.js',
        'display/api.js'
      ];
    nodeUtil.p2jlog = log;
    nodeUtil.p2jinfo = info;
    nodeUtil.p2jwarn = warn;
    nodeUtil.p2jerror = error;
    nodeUtil.verbosity = function (verbo) {
      if (!isNaN(verbo)) {
        if (verbo <= ERRORS) {
          verbo = ERRORS;
        } else if (verbo >= INFOS) {
          verbo = INFOS;
        }
        verbosity = verbo;
      } else {
        verbosity = ERRORS;
      }
    };
    nodeUtil.verbosity(INFOS);
    var PDFPageParser = function () {
        'use strict';
        var _nextId = 1;
        var _name = 'PDFPageParser';
        var RenderingStates = {
            INITIAL: 0,
            RUNNING: 1,
            PAUSED: 2,
            FINISHED: 3
          };
        var _addField = function (field) {
          if (!PDFField.isFormElement(field))
            return;
          var oneField = new PDFField(field, this.viewport, this.Fields, this.Boxsets);
          oneField.processField();
        };
        var cls = function (pdfPage, id, scale, ptiParser) {
          nodeEvents.EventEmitter.call(this);
          var _id = _nextId++;
          this.get_id = function () {
            return _id;
          };
          this.get_name = function () {
            return _name + _id;
          };
          this.id = id;
          this.pdfPage = pdfPage;
          this.ptiParser = ptiParser;
          this.scale = scale || 1;
          this.viewport = this.pdfPage.getViewport(this.scale);
          this.renderingState = RenderingStates.INITIAL;
          this.Fields = [];
          this.Boxsets = [];
          Object.defineProperty(this, 'width', {
            get: function () {
              return PDFUnit.toFormX(this.viewport.width);
            },
            enumerable: true
          });
          Object.defineProperty(this, 'height', {
            get: function () {
              return PDFUnit.toFormY(this.viewport.height);
            },
            enumerable: true
          });
        };
        nodeUtil.inherits(cls, nodeEvents.EventEmitter);
        cls.prototype.destroy = function () {
          this.pdfPage.destroy();
        };
        cls.prototype.getPagePoint = function (x, y) {
          return this.viewport.convertToPdfPoint(x, y);
        };
        cls.prototype.parsePage = function (callback, errorCallBack) {
          if (this.renderingState !== RenderingStates.INITIAL)
            error('Must be in new state before drawing');
          this.renderingState = RenderingStates.RUNNING;
          var canvas = createScratchCanvas(1, 1);
          var ctx = canvas.getContext('2d');
          var self = this;
          function pageViewDrawCallback(error) {
            self.renderingState = RenderingStates.FINISHED;
            if (error) {
              var errMsg = 'An error occurred while rendering the page ' + (self.id + 1) + ':\n' + error.message + ':\n' + error.stack;
              errorCallBack(errMsg);
            } else {
              if (self.ptiParser) {
                var extraFields = self.ptiParser.getFields(parseInt(self.id) + 1);
                _.each(extraFields, _addField, self);
              }
              _.extend(self, ctx.canvas);
              self.stats = self.pdfPage.stats;
              nodeUtil.p2jinfo('page ' + (self.id + 1) + ' is rendered successfully.');
              callback();
            }
          }
          var renderContext = {
              canvasContext: ctx,
              viewport: this.viewport
            };
          self.pdfPage.render(renderContext).then(function pdfPageRenderCallback() {
            self.pdfPage.getAnnotations().then(function (fields) {
              _.each(fields, _addField, self);
              pageViewDrawCallback(null);
            });
          }, function pdfPageRenderError(error) {
            pageViewDrawCallback(error);
          });
        };
        return cls;
      }();
    var PDFJSClass = function () {
        'use strict';
        var _nextId = 1;
        var _name = 'PDFJSClass';
        var _sufInfo = '_fieldInfo.xml';
        var _getMetaDataString = function (metadata, key) {
          var retVal = 'unknown';
          if (metadata && metadata.has(key)) {
            retVal = encodeURIComponent(metadata.get(key));
          }
          return retVal;
        };
        var _getMetaDataInt = function (metadata, key) {
          var retVal = _getMetaDataString(metadata, key);
          retVal = parseInt(retVal);
          if (retVal == null || isNaN(retVal))
            retVal = -1;
          return retVal;
        };
        var cls = function (needRawText) {
          nodeEvents.EventEmitter.call(this);
          var _id = _nextId++;
          this.get_id = function () {
            return _id;
          };
          this.get_name = function () {
            return _name + _id;
          };
          this.pdfDocument = null;
          this.pages = [];
          this.pageWidth = 0;
          this.rawTextContents = [];
          this.needRawText = needRawText;
        };
        nodeUtil.inherits(cls, nodeEvents.EventEmitter);
        cls.prototype.parsePDFData = function (arrayBuffer) {
          this.pdfDocument = null;
          var parameters = {
              password: '',
              data: arrayBuffer
            };
          var self = this;
          PDFJS.getDocument(parameters).then(function getDocumentCallback(pdfDocument) {
            self.load(pdfDocument, 1);
          }, function getDocumentError(message, exception) {
            var errMsg = 'An error occurred while parsing the PDF: ' + message;
            nodeUtil.p2jwarn(errMsg);
            self.emit('pdfjs_parseDataError', errMsg);
          }, function getDocumentProgress(progressData) {
            nodeUtil.p2jinfo('Loading progress: ' + progressData.loaded / progressData.total + '%');
          });
        };
        cls.prototype.load = function (pdfDocument, scale) {
          this.pdfDocument = pdfDocument;
          var pagesCount = pdfDocument.numPages;
          var pagePromises = [];
          for (var i = 1; i <= pagesCount; i++)
            pagePromises.push(pdfDocument.getPage(i));
          var pagesPromise = PDFJS.Promise.all(pagePromises);
          nodeUtil.p2jinfo('PDF loaded. pagesCount = ' + pagesCount);
          var self = this;
          pagesPromise.then(function (promisedPages) {
            self.parsePage(promisedPages, 0, 1.5);
          });
          pdfDocument.getMetadata().then(function (data) {
            self.documentInfo = data.info;
            self.metadata = data.metadata;
            self.parseMetaData();
          });
        };
        cls.prototype.parseMetaData = function () {
          var self = this;
          var info = self.documentInfo;
          var metadata = self.metadata;
          var pdfTile = '';
          if (metadata && metadata.has('dc:title')) {
            pdfTile = metadata.get('dc:title');
          } else if (info && info['Title'])
            pdfTile = info['Title'];
          var formAttr = {
              AgencyId: '',
              Name: '',
              MC: false,
              Max: 1,
              Parent: ''
            };
          if (metadata) {
            formAttr.AgencyId = _getMetaDataString(metadata, 'pdfx:agencyid');
            if (formAttr.AgencyId != 'unknown')
              pdfTile = formAttr.AgencyId;
            formAttr.Name = _getMetaDataString(metadata, 'pdfx:name');
            formAttr.MC = _getMetaDataString(metadata, 'pdfx:mc') === 'true';
            formAttr.Max = _getMetaDataInt(metadata, 'pdfx:max');
            formAttr.Parent = _getMetaDataInt(metadata, 'pdfx:parent');
          }
          self.emit('pdfjs_parseDataReady', {
            Transcoder: pkInfo._id,
            Agency: pdfTile,
            Id: formAttr
          });
        };
        cls.prototype.parsePage = function (promisedPages, id, scale) {
          nodeUtil.p2jinfo('start to parse page:' + (id + 1));
          var self = this;
          var pdfPage = promisedPages[id];
          var pageParser = new PDFPageParser(pdfPage, id, scale, this.ptiParser);
          function continueOnNextPage() {
            nodeUtil.p2jinfo('complete parsing page:' + (id + 1));
            if (id === self.pdfDocument.numPages - 1) {
              self.emit('pdfjs_parseDataReady', {
                Pages: self.pages,
                Width: self.pageWidth
              });
            } else {
              process.nextTick(function () {
                self.parsePage(promisedPages, ++id, scale);
              });
            }
          }
          ;
          pageParser.parsePage(function () {
            if (!self.pageWidth)
              self.pageWidth = pageParser.width;
            var page = {
                Height: pageParser.height,
                HLines: pageParser.HLines,
                VLines: pageParser.VLines,
                Fills: pageParser.Fills,
                Texts: pageParser.Texts,
                Fields: pageParser.Fields,
                Boxsets: pageParser.Boxsets
              };
            self.pages.push(page);
            if (self.needRawText) {
              pdfPage.getTextContent().then(function (textContent) {
                self.rawTextContents.push(textContent);
                nodeUtil.p2jinfo('complete parsing raw text content:' + (id + 1));
                continueOnNextPage();
              });
            } else {
              continueOnNextPage();
            }
          }, function (errMsg) {
            self.emit('pdfjs_parseDataError', errMsg);
          });
        };
        cls.prototype.getRawTextContent = function () {
          var retVal = '';
          if (!this.needRawText)
            return retVal;
          _.each(this.rawTextContents, function (textContent, index) {
            _.each(textContent.bidiTexts, function (textObj, idx) {
              retVal += textObj.str + '\r\n';
            });
            retVal += '----------------Page (' + index + ') Break----------------\r\n';
          });
          return retVal;
        };
        cls.prototype.destroy = function () {
          this.removeAllListeners();
          if (this.pdfDocument)
            this.pdfDocument.destroy();
          this.pdfDocument = null;
          this.pages = null;
          this.rawTextContents = null;
        };
        return cls;
      }();
    module.exports = PDFJSClass;
  });
  require.define('/package.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      'name': 'pdf2json',
      '_id': 'pdf2json@0.7.1',
      'version': '0.7.1',
      'description': 'A PDF file parser that converts PDF binaries to text based JSON, powered by porting a fork of PDF.JS to Node.js',
      'keywords': [
        'pdf',
        'pdf parser',
        'convert pdf to json',
        'server side PDF parser',
        'port pdf.js to node.js',
        'PDF binary to text',
        'commandline utility to parse pdf to json',
        'JSON',
        'javascript',
        'PDF canvas',
        'pdf.js fork'
      ],
      'author': {
        'name': 'Modesty Zhang',
        'email': 'modestyz@hotmail.com',
        'url': 'http://www.codeproject.com/script/Articles/MemberArticles.aspx?amid=62372'
      },
      'homepage': 'https://github.com/modesty/pdf2json',
      'repository': {
        'type': 'git',
        'url': 'git://github.com/modesty/pdf2json.git'
      },
      'main': './pdfparser.js',
      'scripts': { 'test': './test' },
      'engines': { 'node': '>=0.8' },
      'bin': { 'pdf2json': './bin/pdf2json' },
      'dependencies': {
        'xmldom': '>=0.1.13',
        'underscore': '>=1.4.2',
        'optimist': '>=0.3.5',
        'async': '>=0.2.6'
      },
      'devDependencies': {},
      'maintainers': [{
          'name': 'modesty',
          'email': 'modestyz@gmail.com'
        }],
      'contributors': [],
      'bugs': {
        'url': 'http://github.com/modesty/pdf2json/issues',
        'email': 'modestyz@hotmail.com'
      },
      'licenses': [{
          'type': 'LGPL',
          'url': 'http://www.gnu.org/licenses/lgpl.html'
        }],
      '_from': 'pdf2json@*',
      'gitHead': 'd018b8a18e97ed448ed6184206b1de4bd2755e16',
      'bundleDependencies': [
        'xmldom',
        'underscore',
        'optimist',
        'async'
      ],
      '_shasum': '8888d73c26938e4d8887b633d6e4b4422dcd30cb',
      '_npmVersion': '1.4.13',
      '_npmUser': {
        'name': 'modesty',
        'email': 'modestyz@hotmail.com'
      },
      'dist': {
        'shasum': '8888d73c26938e4d8887b633d6e4b4422dcd30cb',
        'tarball': 'http://registry.npmjs.org/pdf2json/-/pdf2json-0.7.1.tgz'
      },
      'directories': {},
      '_resolved': 'https://registry.npmjs.org/pdf2json/-/pdf2json-0.7.1.tgz'
    };
  });
  require.define('/lib/pdfimage.js', function (module, exports, __dirname, __filename) {
    var PDFImage = function () {
      'use strict';
      var _src = '';
      var _onload = null;
      this.__defineSetter__('onload', function (val) {
        _onload = val;
      });
      this.__defineGetter__('onload', function () {
        return _onload;
      });
      this.__defineSetter__('src', function (val) {
        _src = val;
        if (_onload)
          _onload();
      });
      this.__defineGetter__('src', function () {
        return _src;
      });
      this.btoa = function (val) {
        if (typeof window === 'undefined') {
          return new Buffer(val, 'ascii').toString('base64');
        } else if (typeof window.btoa === 'function')
          return window.btoa(val);
        return '';
      };
    };
    module.exports = PDFImage;
  });
  global.ABPDF = require('/abpdfparser.js');
}.call(this, this));
